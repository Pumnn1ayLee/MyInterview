## 自我介绍

你好，我叫李富荣，本科毕业于北京理工大学珠海学院，专业是通信工程，目前技术栈是Golang、MySql、Redis，在上一家实习公司是做助理后端开发，负责与高级工程师协作，用Gin和Gorm等构建和维护系统的后端服务。然后来应聘贵公司的游戏服务器开发工程师。

# 项目深挖

这是一个涉及Golang后端开发的项目，主要关注材料管理服务。以下是对项目的更深入了解和可能相关的问题，可以在面试中提供更多的见解：

### 简单介绍：

当涉及到材料管理系统项目时，这是一个关键的组成部分，它允许公司有效地管理、追踪和优化材料的使用和供应链。以下是一个更实际的项目介绍：

**项目名称：** 材料管理系统

**我的角色：** 我在项目中担任Golang助理开发工程师的职务，负责与高级工程师协作，构建和维护系统的后端服务。

**项目概述：** 材料管理系统是为公司提供了一种全面的材料管理解决方案。它允许公司有效地管理、追踪和优化材料的使用和供应链。项目的核心目标是提供高性能、可扩展和安全的材料管理后端服务，以支持以下功能：

- 材料数据的录入和维护，包括材料属性、库存和供应商信息。
- 订单管理，包括订单创建、处理和交付跟踪。
- 用户身份验证和授权，以确保只有授权用户能够访问敏感数据。

**技术栈和工具：**

- **编程语言：** 主要使用Golang，具有高性能和并发处理能力，适合处理大量的请求和数据。
- **Web框架：** 使用Gin框架处理HTTP请求和路由，构建中间件以支持身份验证和授权功能。
- **数据库交互：** 通过GORM库与MySQL数据库进行数据交互，确保材料数据和订单的可靠持久化存储。
- **性能优化：** 利用Redis缓存机制优化材料订购列表的访问性能，提高响应速度。
- **容器化：** 采用Docker容器化应用程序，以简化开发、测试和部署流程，同时确保环境一致性。
- **版本控制：** 使用Git进行代码版本控制，与团队成员协同开发和维护代码。

**关键挑战和解决方案：**

- **用户认证和授权：** 项目需要确保数据的安全性和访问权限。我们使用Gin框架的中间件功能，轻松验证用户身份，并根据权限设置进行访问控制。
- **数据库设计和性能优化：** 与高级工程师协助数据库表结构设计，优化数据库查询，以提高系统性能。

这个项目不仅提高了公司的材料管理效率，还确保数据的安全性和准确性。它为用户提供了可靠的工具，以管理公司材料和订单的方方面面。通过现代技术栈和团队协作，项目达到了这些关键目标

## **Gin框架**

### Gin是一个轻量级的Web框架，为什么选择了它？有没有考虑其他框架？在什么情况下Gin是一个合适的选择？

 答：Gin框架以高性能和低内存消耗著称，这使得它特别适合处理大量请求。如果项目需要快速响应客户端请求，并且要求低资源消耗，Gin是一个合适的选择。

Gin提供了丰富的中间件支持，这使得实现认证、授权、请求日志记录、CORS支持等常见功能变得非常容易。在需要对HTTP请求和响应进行细粒度控制的情况下，Gin的中间件非常有用。

Gin框架提供了强大的路由引擎，可以根据HTTP请求的路径和方法将请求分派到相应的处理函数。此外，它内置了参数解析，支持URL参数、查询字符串参数和JSON数据的解析，使请求处理更加方便。

如果项目主要涉及处理HTTP请求和构建RESTful API服务，那么Gin是一个自然的选择。它被设计用于Web开发，提供了处理HTTP请求的核心功能。

选择Gin框架并不是唯一的选择，其他Web框架如Beego、Echo、Iris等也是可行的。

简单来说：Gin通常是在需要高性能、轻量级和快速开发RESTful API时的合适选择。

### 项目中如何处理路由、中间件和请求/响应？

 答：

路由处理：

   通过Gin的路由引擎完成。你可以使用gin.Default()或自定义gin.New()来创建一个Gin的实例。

  使用HTTP方法（GET、POST、PUT、DELETE等）定义路由，将不同的URL映射到处理函数。

```go
router.GET("/api/resource", func(c *gin.Context) {
    // 处理GET请求
})
```

中间件：

中间件是在请求到达处理函数之前或之后执行的代码段，用于添加功能或进行预处理。

你可以使用`Use`方法附加中间件，或在特定路由上使用`Group`方法应用中间件。

```go
router.Use(func(c *gin.Context) {
    // 执行一些预处理操作，如日志记录
    c.Next() // 继续执行下一个中间件或处理函数
})
```

请求和响应：

Gin提供了方便的方法来获取请求数据、处理响应和状态码。

你可以使用`c.ShouldBind`或`c.ShouldBindJSON`等方法来解析请求数据，使用`c.JSON`或`c.XML`等方法来构建响应。

例如，解析JSON请求和返回JSON响应：

```go
var requestData MyStruct
if err := c.ShouldBindJSON(&requestData); err != nil {
    c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
    return
}
// 处理请求数据
c.JSON(http.StatusOK, gin.H{"message": "Success"})
```

### GET和POST的区别

1. **HTTP请求方法**:
   - GET：用于从服务器获取数据。它是幂等的，这意味着多次请求相同的URL和参数，不会对服务器状态产生影响。
   - POST：用于向服务器提交数据，通常用于创建、更新或提交信息。POST请求可能会对服务器状态进行更改。
2. **数据传递**:
   - GET：数据通常附在URL的查询字符串中，通过URL参数传递给服务器。这些参数对用户可见，因此不适合传递敏感信息。
   - POST：数据通常包含在请求的消息体中，对用户不可见，因此更适合传递敏感信息和大量数据。
3. **数据长度**:
   - GET：由于数据附加在URL中，因此数据长度受到URL长度的限制，通常不适合传递大数据。
   - POST：由于数据包含在请求消息体中，因此可以传递大量数据。
4. **安全性**:
   - GET：由于数据显示在URL中，不适合传递敏感信息，因为它可能会被浏览器历史记录、代理服务器等记录。
   - POST：更适合传递敏感信息，因为数据不会直接显示在URL中，但仍然需要使用安全通信协议（如HTTPS）来保护数据传输的安全性。
5. **缓存**:
   - GET：通常被浏览器缓存，以便提高性能。如果多次发出相同的GET请求，浏览器可能从缓存中获取响应而不重新请求服务器。
   - POST：不会被浏览器缓存，每次请求都会向服务器发出一个新的POST请求。

### 能否提供一些Gin中间件的例子，以展示它们是如何用于业务功能的？

身份验证中间件：

```go
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 在此执行身份验证逻辑
        if authenticated {
            c.Next()
        } else {
            c.AbortWithStatus(http.StatusUnauthorized)
        }
    }
}
```

在这个示例中，`AuthMiddleware`中间件用于验证用户身份。如果用户通过身份验证，请求将继续传递给下一个处理程序，否则返回未经授权的状态码。

日志记录中间件：

```go
func LoggerMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 记录请求信息，如路径、方法、IP地址等
        log.Println("Request:", c.Request.Method, c.Request.URL, c.ClientIP())
        c.Next()
    }
}
```

`LoggerMiddleware`中间件用于记录每个请求的相关信息，如请求方法、URL和客户端IP地址。这对于跟踪和故障排除非常有帮助。

错误处理中间件：

```go
func ErrorMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if r := recover(); r != nil {
                log.Println("Recovered from panic:", r)
                c.AbortWithStatus(http.StatusInternalServerError)
            }
        }()
        c.Next()
    }
}

```

`ErrorMiddleware`中间件用于捕获处理程序中的恐慌（panic），并返回适当的错误响应。这有助于避免应用程序崩溃并提供友好的错误页面或响应。

## GORM和MySQL

### 项目中是如何使用GORM库与MySQL数据库进行数据交互的？有没有涉及到数据库迁移或查询优化？

1. **安装和导入GORM库**：首先，您需要安装GORM库并在项目中导入它，以便与MySQL数据库进行交互。这可以通过导入相应的包以及设置数据库连接信息来完成。
2. **定义模型结构**：在项目中，您需要定义与数据库表对应的模型结构。这些模型结构通常使用Go的结构体来表示，每个字段对应表中的列。您还可以使用GORM的标签来指定字段名称、主键、外键等信息。
3. **创建数据库表**：GORM支持自动创建数据库表，您可以使用`AutoMigrate`方法创建表。此时，GORM将根据模型结构创建数据库表，确保模型字段与表字段的映射正确。
4. **插入、查询、更新和删除数据**：使用GORM的方法，您可以执行各种数据库操作，包括插入、查询、更新和删除数据。例如，使用`Create`方法插入数据，使用`Find`方法查询数据，使用`Update`方法更新数据，使用`Delete`方法删除数据。
5. **数据库迁移**：数据库迁移是将数据库结构更新到新版本的过程。如果您需要对数据库模型进行更改，可以创建迁移文件，然后使用GORM的迁移工具来应用这些更改。这有助于保持数据库模式与应用程序代码的同步。
6. **查询优化**：为了提高查询性能，您可以使用GORM提供的查询选项和方法。例如，您可以使用`Preload`方法来预加载关联数据，使用`Where`和`Order`来筛选和排序数据，使用`Limit`和`Offset`来分页查询等。
7. **事务处理**：如果需要执行具有原子性的多个数据库操作，您可以使用GORM提供的事务支持。这确保了一组操作要么全部成功，要么全部失败，从而维护数据库的一致性。
8. **错误处理**：在与数据库交互时，及时处理可能出现的错误是很重要的。您可以检查GORM方法的返回错误来处理数据库操作中的问题。

### 在使用数据库时是否涉及事务处理？从项目中举例说明？

是的，在许多数据库应用中，事务处理是非常重要的，它确保了数据库操作的原子性，即一组操作要么全部成功，要么全部失败，以维护数据库的一致性。

举一个示例，假设您正在开发一个在线电子商务平台的后端系统，其中用户可以下订单并购买商品。在这个项目中，事务处理可能会用于以下情况：

**订单处理**：当用户下订单并购买商品时，需要执行一系列数据库操作，包括：

1. 创建订单记录。
2. 扣除用户账户中的付款金额。
3. 更新库存以反映已出售的商品数量。
4. 记录交易历史。

这些操作必须在同一事务中进行，以确保数据一致性。如果任何一个操作失败，整个事务应该回滚，以防止数据库状态不一致。

在这种情况下，您可以使用GORM或其他数据库操作库提供的事务支持来执行这些操作。您可以创建一个事务，将上述操作包装在其中，然后提交或回滚事务，具体取决于操作的结果。

举个gorm伪代码示例：

```go
tx := db.Begin() // 开始事务

// 在事务中执行操作
if err := tx.Create(&order).Error; err != nil {
    tx.Rollback() // 操作失败，回滚事务
} else if err := tx.Model(&user).Update("balance", updatedBalance).Error; err != nil {
    tx.Rollback() // 操作失败，回滚事务
} else if err := tx.Model(&product).Update("stock", updatedStock).Error; err != nil {
    tx.Rollback() // 操作失败，回滚事务
} else {
    tx.Commit() // 操作成功，提交事务
}
```

上述示例中，如果在事务中的任何一步操作失败，将执行回滚，确保数据库的一致性。如果所有操作成功，事务将被提交。

### 如何确保数据一致性和安全性？

1. 使用事务处理来确保一组操作要么全部成功，要么全部失败。
2. 在数据库中定义适当的数据约束，如唯一性约束和外键约束。
3. 使用安全协议如HTTPS来传输数据。
4. 实施权限和访问控制，限制对敏感数据的访问。
5. 及时处理数据库操作中的错误，记录错误日志。
6. 定期备份数据库，以便数据恢复。
7. 启用审计日志来跟踪数据库操作。
8. 对敏感数据进行加密。
9. 定期进行安全漏洞扫描和修复。
10. 实施访问控制列表，确保只有授权的用户能够访问数据。
11. 使用滚动更新策略以避免数据不一致或中断服务。
12. 使用事务处理来确保一组操作要么全部成功，要么全部失败。
13. 在数据库中定义适当的数据约束，如唯一性约束和外键约束。
14. 使用安全协议如HTTPS来传输数据。
15. 实施权限和访问控制，限制对敏感数据的访问。
16. 及时处理数据库操作中的错误，记录错误日志。
17. 定期备份数据库，以便数据恢复。
18. 启用审计日志来跟踪数据库操作。
19. 对敏感数据进行加密。
20. 定期进行安全漏洞扫描和修复。
21. 实施访问控制列表，确保只有授权的用户能够访问数据。
22. 使用滚动更新策略以避免数据不一致或中断服务。

## Redis缓存

### Redis是如何用于优化材料订购列表的访问性能的？

1. 缓存经常访问的数据，以降低访问延迟。
2. 缓存查询结果，特别是计算密集型或耗时的查询。
3. 实时更新Redis缓存，以确保数据同步。
4. 设置缓存数据的过期时间，以确保数据不会太过时。
5. 使用合适的数据结构来存储数据，以便高效查询和操作。
6. 如果数据量大，考虑使用Redis集群或分片来扩展性能。
7. 保护数据一致性，特别是在缓存数据可能失效的情况下。
8. 定期监控Redis性能并根据需求进行调整。

### 有没有在项目中用到其他缓存策略或技术？

## Docker和Docker Compose

### Docker是如何用于容器化应用程序的？有没有特定的容器架构或部署策略？

1. **容器化**：Docker将应用程序及其依赖项封装到一个容器中。容器是轻量级、可移植的运行环境，包括应用程序、运行时、系统工具和系统库。
2. **Docker镜像**：Docker使用镜像作为容器的构建块。镜像是一个只读的文件，包含了运行应用程序所需的所有内容。开发人员可以创建自定义镜像或使用公共镜像仓库中的现成镜像。
3. **Docker容器**：容器是基于镜像创建的可运行实例。它们隔离了应用程序和其依赖项，确保应用程序在不同环境中的一致性运行。
4. **容器编排**：Docker容器可以由容器编排工具管理，如Docker Compose、Kubernetes或Docker Swarm。这些工具可以协调多个容器，以实现应用程序的高可用性和扩展性。
5. **多环境支持**：Docker容器可以在不同的开发、测试和生产环境中运行，因为它们隔离了依赖关系。这简化了应用程序的部署和迁移。
6. **版本控制**：Docker镜像和容器可以通过版本控制来管理，以确保应用程序的可重复构建和部署。

特定的容器架构和部署策略取决于项目需求和规模。以下是一些容器化应用程序的最佳实践：

- 使用Dockerfile来定义应用程序的构建步骤，以确保镜像的可重复性和可维护性。
- 使用容器编排工具来管理多个容器，以确保应用程序的高可用性和自动扩展。
- 遵循最小原则，尽量减小镜像的大小，以减少网络传输和存储开销。
- 定期更新和维护容器镜像，以确保系统的安全性和稳定性。
- 考虑容器的网络配置和存储卷设置，以满足应用程序的特定需求

### 如何使用Docker Compose进行本地开发环境管理？有没有在开发、测试和生产环境中使用不同的容器配置？

1. **编写Docker Compose文件**：创建一个`docker-compose.yml`文件，定义您的应用程序的容器、服务和它们的配置。这包括容器映像、端口映射、环境变量等。
2. **本地开发容器配置**：在`docker-compose.yml`中，您可以使用本地开发所需的配置。例如，您可以指定开发数据库的连接字符串、本地文件系统的挂载目录等。
3. **启动容器**：在项目根目录中运行`docker-compose up`命令，Docker Compose将创建并启动您定义的容器和服务。
4. **实时应用程序开发**：如果您的应用程序需要热重载或实时反馈，确保相关工具和配置已包含在容器中。
5. **容器连接**：如果应用程序的容器需要连接到其他容器，确保在Compose文件中配置适当的网络连接。

**在开发、测试和生产环境中使用不同的容器配置：**

1. **使用多个Compose文件**：Docker Compose支持使用多个Compose文件。您可以创建一个基本的`docker-compose.yml`文件，然后为每个环境（如开发、测试、生产）创建额外的Compose文件。
2. **环境特定的Compose文件**：在每个环境特定的Compose文件中，覆盖需要根据环境而异的配置。例如，您可以为测试环境指定测试数据库容器，而为生产环境指定生产数据库容器。
3. **使用环境变量**：在Compose文件中，可以使用环境变量来引用不同环境的配置。在容器内部，根据环境变量加载相应的配置文件或设置不同的参数。
4. **容器替代**：在Compose文件中，您还可以指定容器的替代版本。这意味着在不同环境中，您可以使用具有相同接口的不同容器，以满足不同环境的要求。

## 版本控制和团队协作

### 项目中如何使用Git进行版本控制？有没有使用特定的工作流程？

**项目中如何使用Git：**

1. **初始化Git仓库**：在项目目录中运行`git init`命令以初始化Git仓库。这将创建一个`.git`子目录，用于存储版本控制信息。
2. **创建和切换分支**：通常，项目会使用不同的分支来管理不同的功能或修复。使用`git branch`和`git checkout`命令来创建和切换分支。
3. **添加和提交更改**：使用`git add`命令将更改添加到暂存区，然后使用`git commit`命令将更改提交到仓库。每次提交都应该包括有意义的提交消息。
4. **拉取和推送**：在多人协同开发时，使用`git pull`命令从远程仓库拉取最新的更改，使用`git push`命令将您的更改推送到远程仓库。
5. **解决冲突**：如果多人在相同文件的相同部分进行了更改，可能会产生冲突。使用`git mergetool`或手动解决冲突，然后提交更改。
6. **分支合并**：当一个功能或修复完成后，使用`git merge`命令将分支合并到主分支或其他适当的分支。

**常见的Git工作流程：**

1. **集中式工作流**：这是最简单的工作流，通常用于小型项目。所有开发者都在主分支上工作，依次提交更改。
2. **特性分支工作流**：每个功能或修复都有自己的分支。开发者在特性分支上工作，完成后合并到主分支。
3. **Git Flow工作流**：这是一种流行的工作流程，将主分支分为主要版本和维护版本。它定义了不同的分支，如特性分支、发行分支和维护分支。
4. **GitHub Flow工作流**：类似于Git Flow，但更简单。开发者在主分支上工作，创建特性分支，完成后合并到主分支，并部署。
5. **GitLab Flow工作流**：与GitHub Flow相似，但包括持续集成和自动部署。

### 如何与团队成员协同开发和管理代码？有没有使用特定的开发方法或工具？

**协同开发和代码管理的最佳实践：**

1. **版本控制系统**：使用版本控制系统（如Git）来管理代码。每个团队成员应该在自己的分支上工作，然后将更改合并到主分支或开发分支。
2. **代码审查**：定期进行代码审查，以确保代码质量和一致性。工具如GitHub或GitLab的Pull Request功能可用于简化代码审查。
3. **文档编写**：编写清晰的代码注释和文档，以便其他团队成员理解和使用您的代码。使用文档生成工具（如Doxygen或Javadoc）来自动生成文档。
4. **持续集成**：使用持续集成工具（如Jenkins、Travis CI或CircleCI）来自动化构建和测试。这有助于及早发现问题并确保代码的稳定性。
5. **任务管理**：使用任务管理工具（如JIRA、Trello、Asana或GitHub项目）来跟踪任务、问题和功能请求。确保任务清单和优先级得到管理。
6. **协同工作和沟通**：使用协同工作工具（如Slack、Microsoft Teams、或基于Web的协作工具）进行实时沟通和合作。

**特定的开发方法和工具：**

1. **敏捷开发**：使用敏捷开发方法，如Scrum或Kanban，以实现灵活的开发和迭代。敏捷方法鼓励交互和反馈，有助于满足需求变更。
2. **集成开发环境（IDE）**：使用适当的IDE来加速开发，并确保一致的代码样式和质量。
3. **持续部署**：使用持续部署工具（如Docker和Kubernetes）来自动化部署，以确保代码变更快速部署到生产环境。
4. **代码分析工具**：使用代码分析工具（如SonarQube）来检测潜在问题和代码质量问题。
5. **代码库托管**：使用代码库托管平台，如GitHub、GitLab或Bitbucket，以进行代码存储、版本控制和协同开发。
6. **单元测试和集成测试**：进行单元测试和集成测试，以确保代码质量和稳定性。
7. **自动化工具**：使用自动化工具（如Ansible或Chef）来管理和配置开发和生产环境。

## 认证和授权

### 讲一下用户认证和授权的实现，特别是如何保护数据和限制访问权限。

**用户认证（Authentication）：**

1. **用户注册和登录**：允许用户注册账户，并提供用户名和密码等凭据。用户登录时，系统验证提供的凭据。
2. **使用安全凭据存储**：将用户密码存储为安全哈希值，而不是明文密码。常用的哈希算法包括BCrypt和Argon2。这样，即使数据库泄露，用户密码也不会暴露。
3. **使用多因素认证**：为用户提供双因素认证选项，如短信验证码、令牌或生物识别。这提高了账户的安全性。
4. **会话管理**：在用户登录后，生成一个会话令牌，将其存储在用户的浏览器中。会话令牌用于保持用户的登录状态。定期更换会话令牌以防止会话劫持。

**用户授权（Authorization）：**

1. **角色和权限管理**：定义不同的用户角色和权限。例如，管理员可以访问所有资源，而普通用户只能访问其自己的资源。
2. **访问控制列表（ACL）**：为资源定义ACL，指定哪些用户或角色可以访问资源。ACL可以存储在数据库或文件中。
3. **中间件**：使用中间件来检查用户权限。在每个请求中，中间件可以验证用户的角色和权限，以决定是否允许访问资源。
4. **认证令牌**：使用认证令牌，如JSON Web Tokens (JWT)，为用户分配令牌，该令牌包含用户身份和权限信息。服务器验证JWT以授权用户。
5. **API端点保护**：确保只有经过身份验证和授权的用户可以访问受保护的API端点。通常，通过检查请求头中的令牌或Cookie来实现。
6. **错误处理**：在拒绝访问时，返回适当的HTTP状态码和错误消息，以便客户端了解其权限限制。

### 项目中使用哪些认证/授权机制？是否使用了JWT、OAuth2或其他身份验证方案？

1. **基本身份验证（Basic Authentication）**：基于用户名和密码的简单认证方式，通常用于用户登录。它将用户名和密码编码并包含在HTTP请求头中。项目中可能会使用它来验证用户登录。
2. **JSON Web Tokens (JWT)**：JWT是一种令牌（Token）的认证机制，用于安全传输用户身份和权限信息。它在项目中常用于创建令牌，将用户身份信息编码在其中，然后将令牌用于后续请求的授权。
3. **OAuth2**：OAuth2是一种用于授权的开放标准，通常用于允许第三方应用程序访问用户资源。它在项目中可能用于提供对外部应用程序的安全访问权限。
4. **角色和权限控制**：项目中可能会使用自定义的角色和权限控制机制。不同用户角色可能具有不同的权限，例如管理员、普通用户等。
5. **OAuth2单点登录（SSO）**：SSO是一种身份验证方法，允许用户使用一组凭据（通常是用户名和密码）登录多个应用程序。它在项目中可能用于集成多个应用程序的用户身份验证。
6. **会话管理**：会话管理是一种用于跟踪用户登录状态的机制，通常涉及到存储会话令牌或Cookie。它有助于在用户登录后维护其身份状态。

项目中的认证和授权机制通常根据需求而定，可以根据应用程序的特性选择合适的机制。一些项目可能会同时使用多种机制，以满足不同的身份验证和授权需求。最终，确保身份验证和授权机制能够保护数据安全和用户隐私是至关重要的。

## **协助高级工程师**

### 在项目中，你是如何与高级工程师协同工作的？

1. **遵循项目规范和代码风格**：始终遵循项目的规范和代码风格，以确保一致的代码质量。这有助于高级工程师和其他团队成员更容易理解和维护我的代码。
2. **参与需求讨论**：在项目需求讨论中积极参与，与高级工程师一起理解项目需求，并提供反馈和建议。这有助于确保项目的技术实现与业务需求相匹配。
3. **协同开发**：与高级工程师一起协同开发功能和模块。我会参与编写、测试和维护代码，按照高级工程师的指导完成任务。
4. **学习和成长**：积极学习和提高自身技能，以更好地理解和应用高级工程师的经验和知识。高级工程师可以提供指导和建议，我会尽力吸取经验教训。
5. **代码审查**：参与代码审查，接受高级工程师的审查和反馈。这有助于识别潜在问题并提高代码质量。
6. **文档编写**：参与编写技术文档、用户手册和代码注释。确保项目文档的完整性，使整个团队更容易理解项目细节。
7. **数据库设计和优化**：与高级工程师一起参与数据库设计和优化工作。这可能涉及表结构设计、查询性能优化和索引创建等任务。
8. **团队协作**：积极参与团队会议和讨论，分享意见和建议。与高级工程师和其他团队成员协作，确保项目的成功。

### 你参与了哪些开发任务，以及如何确保与团队协作和沟通？

**开发任务：**

1. **功能开发**：我参与了多个功能的设计和开发，包括用户身份验证、订单管理、材料数据的处理等。
2. **数据库设计和优化**：我协助高级工程师进行数据库表结构设计，并帮助优化了某些数据库查询以提高性能。
3. **中间件和路由开发**：我负责处理HTTP请求和路由，使用Gin框架构建中间件来实现部分业务逻辑。
4. **代码维护和测试**：我积极参与代码维护和修复bug，以确保系统的稳定性。此外，我编写了单元测试和集成测试用例，帮助确保代码的质量。

**团队协作和沟通方法：**

1. **每日站会**：我们每天进行站会，分享进展、问题和计划。这有助于团队了解工作状态和协调任务。
2. **项目管理工具**：我们使用项目管理工具（如JIRA或Trello）来跟踪任务和问题。这使得团队成员能够协同工作，并了解任务的状态。
3. **代码审查**：代码审查是团队协作的一部分，我们通过Pull Request工作流程进行代码审查。这有助于发现和解决潜在问题。
4. **实时聊天工具**：我们使用实时聊天工具（如Slack）进行实时沟通，以便及时解决问题和交流想法。
5. **文档和注释**：编写清晰的代码注释和技术文档，以便其他团队成员理解代码和系统设计。
6. **面对面讨论**：有时，面对面的讨论是解决复杂问题的有效方式。我与高级工程师进行面对面讨论，以澄清需求和解决疑虑。





## 计算机网络和操作系统高频

### TCP/UDP

### TCP的三次握手

TCP协议位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。

三次握手原理：

第1次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；

第2次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了；

第3次握手：客户端再回传一个带有ACK标志的数据包，表示我知道了，握手结束。

其中：SYN标志位数置1，表示建立TCP连接；ACK标志表示验证字段。

![image-20230922224023726](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230922224023726.png)

1. 第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位`SYN=1`，序列号`seq=x`。第一次握手前客户端的状态为`CLOSE`，第一次握手后客户端的状态为`SYN-SENT`。此时服务端的状态为`LISTEN`。
2. 第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位`SYN=1`，`ACK=1`，序列号`seq=y`，确认号`ack=x+1`。第二次握手前服务端的状态为`LISTEN`，第二次握手后服务端的状态为`SYN-RCVD`，此时客户端的状态为`SYN-SENT`。（其中`SYN=1`表示要和客户端建立一个连接，`ACK=1`表示确认序号有效）
3. 第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位`ACK=1`，序列号`seq=x+1`，确认号`ack=y+1`。第三次握手前客户端的状态为`SYN-SENT`，第三次握手后客户端和服务端的状态都为`ESTABLISHED`。**此时连接建立完成。**



### 两次握手可以吗？

第三次握手主要为了**防止已失效的连接请求报文段**突然又传输到了服务端，导致产生问题。

- 比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。
- 连接成功，等待数据传输完毕后，就释放了连接。
- 然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。
- 如果不采用三次握手，只要B发出确认，就建立新的连接了，**此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。**

### TCP的四次挥手

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

四次挥手原理：

第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；

第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；

第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；

第4次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手。

其中：FIN标志位数置1，表示断开TCP连接。

![image-20230922224543575](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230922224543575.png)

四次挥手过程详细说明：

1. A的应用进程先向其TCP发出连接释放报文段（`FIN=1，seq=u`），并停止再发送数据，主动关闭TCP连接，进入`FIN-WAIT-1`（终止等待1）状态，等待B的确认。
2. B收到连接释放报文段后即发出确认报文段（`ACK=1，ack=u+1，seq=v`），B进入`CLOSE-WAIT`（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。
3. A收到B的确认后，进入`FIN-WAIT-2`（终止等待2）状态，等待B发出的连接释放报文段。
4. B发送完数据，就会发出连接释放报文段（`FIN=1，ACK=1，seq=w，ack=u+1`），B进入`LAST-ACK`（最后确认）状态，等待A的确认。
5. A收到B的连接释放报文段后，对此发出确认报文段（`ACK=1，seq=u+1，ack=w+1`），A进入`TIME-WAIT`（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间`2MSL`（最大报文段生存时间）后，A才进入`CLOSED`状态。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。

### 第四次挥手为什么要等待2MSL？

- **保证A发送的最后一个ACK报文段能够到达B**。这个`ACK`报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在`2MSL`时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到`CLOSED`状态，若A在`TIME-WAIT`状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到`CLOSED`状态。
- **防止已失效的连接请求报文段出现在本连接中**。A在发送完最后一个`ACK`报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。

### 为什么是四次挥手？

因为当Server端收到Client端的`SYN`连接请求报文后，可以直接发送`SYN+ACK`报文。**但是在关闭连接时，当Server端收到Client端发出的连接释放报文时，很可能并不会立即关闭SOCKET**，所以Server端先回复一个`ACK`报文，告诉Client端我收到你的连接释放报文了。只有等到Server端所有的报文都发送完了，这时Server端才能发送连接释放报文，之后两边才会真正的断开连接。故需要四次挥手。

### 11种状态名词解析：

```
LISTEN：等待从任何远端TCP 和端口的连接请求。
 
SYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。
 
SYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。
 
ESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。
 
FIN_WAIT_1：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。
 
FIN_WAIT_2：等待远端TCP 的连接终止请求。
 
CLOSE_WAIT：等待本地用户的连接终止请求。
 
CLOSING：等待远端TCP 的连接终止请求确认。
 
LAST_ACK：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）
 
TIME_WAIT：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。
TIME_WAIT 两个存在的理由：
          1.可靠的实现tcp全双工连接的终止；
          2.允许老的重复分节在网络中消逝。
 
CLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）
```



### 为什么要有TIME_WAIT状态？

因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报⽂段，如果客户端已经关闭了就收不到了。还有⼀点是避免新旧连接混杂。

### 服务器出现了大量 CLOSE_WAIT 状态如何解决？

⼤量 CLOSE_WAIT 表示程序出现了问题，对⽅的 socket 已经关闭连接，⽽我⽅忙于读或写没有及时关闭连接，需 要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。

### 讲一下SYN超时，洪泛攻击，以及解决策略？

什么 SYN 是洪泛攻击？在 TCP 的三次握⼿机制的第⼀步中，客户端会向服务器发送 SYN 报⽂段。服务器接收到 SYN 报⽂段后会为该 TCP分配缓存和变量，如果攻击分⼦⼤量地往服务器发送 SYN 报⽂段，服务器的连接资源终 将被耗尽，导致内存溢出⽆法继续服务。 

解决策略：当服务器接受到 SYN 报⽂段时，不直接为该 TCP 分配资源，⽽只是打开⼀个半开的套接字。接着会使 ⽤ SYN 报⽂段的源 Id，⽬的 Id，端⼝号以及只有服务器⾃⼰知道的⼀个秘密函数⽣成⼀个 cookie，并把 cookie 作为序列号响应给客户端。 

如果客户端是正常建⽴连接，将会返回⼀个确认字段为 cookie +1 的报⽂段。接下来服务器会根据确认报⽂的源 Id，⽬的 Id，端⼝号以及秘密函数计算出⼀个结果，如果结果的值+1 等于确认字段的值，则证明是刚刚请求连接 的客户端，这时候才为该 TCP 分配资源 

这样⼀来就不会为恶意攻击的 SYN 报⽂段分配资源空间，避免了攻击。

### TCP有哪些特点？

- TCP是**面向连接**的运输层协议。
- **点对点**，每一条TCP连接只能有两个端点。
- TCP提供**可靠交付**的服务。
- TCP提供**全双工通信**。
- **面向字节流**。

### TCP和UDP的区别

TCP是面向连接的，UDP是面向无连接的；

TCP只能一对一通信，UDP支持一对一，一对多，多对一和多对多交互通信；

TCP是面向字节流的，UDP是面向报文的；

TCP是可靠传输，使用流量控制和拥塞控制；UDP是不可靠传输

TCP首部最小20字节，最大60字节；UDP首部仅8字节。

### TCP报文首部有哪些字段，其作用又分别是什么？

![image-20230925233939098](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230925233939098.png)

- **16位端口号**：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序
- **32位序号**：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。
- **32位确认号**：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。
- **4位头部长度**：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。
- **6位标志位**：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）
- **16位窗口大小**：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。
- **16位校验和**：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。
- **16位紧急指针**：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。

### TCP和UDP分别对应的常用应用层协议有哪些？

**基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH**

- **HTTP**：HyperText Transfer Protocol（超文本传输协议），默认端口80
- **FTP**: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)
- **SMTP**: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25
- **TELNET**: Teletype over the Network (网络电传), 默认端口23
- **SSH**：Secure Shell（安全外壳协议），默认端口 22

**基于UDP的应用层协议：DNS、TFTP、SNMP**

- **DNS** : Domain Name Service (域名服务),默认端口 53
- **TFTP**: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69
- **SNMP**：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162。

### TCP的粘包和拆包？如何解决？

TCP是面向流，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一**个完整的包可能会被TCP拆分成多个包进行发送**，**也有可能把多个小的包封装成一个大的数据包发送**，这就是所谓的TCP粘包和拆包问题。

**为什么会产生粘包和拆包呢?**

- 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
- 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；
- 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。

**解决方案：**

- 发送端将每个数据包封装为固定长度。
- 在数据尾部增加特殊字符进行分割。
- 将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。

### TCP是如何确保可靠性的呢？

- 首先，TCP的连接是基于**三次握手**，而断开则是基于**四次挥手**。确保连接和断开的可靠性。
- 其次，TCP的可靠性，还体现在**有状态**;TCP会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- 再次，TCP的可靠性，还体现在**可控制**。它有数据包校验、ACK应答、**超时重传(发送方)**、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

### TCP的滑动窗口机制？

TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。

![image-20230926000238841](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926000238841.png)

TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。

### OSI七层模型及相关协议

物理层：建立、维护、断开物理连接。
数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。
网络层：进行逻辑地址寻址，实现不同网络之间的路径选择，协议有ICMP、IGMP、IP等。
传输层：定义传输数据的协议端口号，以及流量控制和差错校验，协议有TCP、UDP。
会话层：建立、管理、终止会话，指本地主机与远程主机正在进行的会话。
表示层：确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。
应用层：网络服务与最终用户的一个接口，常见的协议有：HTTP、FTP、SMTP、DNS。

### TCP/IP 四层模型

1. 网络接口层
2. 网际层
3. 传输层
4. 应用层

### TCP如何确保可靠性的呢？

- 首先，TCP的连接是基于**三次握手**，而断开则是基于**四次挥手**。确保连接和断开的可靠性。
- 其次，TCP的可靠性，还体现在**有状态**;TCP会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- 再次，TCP的可靠性，还体现在**可控制**。它有数据包校验、ACK应答、**超时重传(发送方)**、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

### TCP的滑动窗口机制

TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。

![image-20230926000730808](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926000730808.png)

TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。

### 详细讲一下拥塞控制？

防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。

**慢开始**

把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。

当 cwnd < ssthresh 时，使用慢开始算法。

当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。

当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。

**拥塞避免**

让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。

**快重传**

有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。

快重传算法可以避免这个问题。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。

发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。

**快恢复**

当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。

在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得TCP的性能有明显的改进。

### HTTP协议

HTTP（Hyper Text Transformer Protocol，超文本传输协议）是一种通信协议，基于TCP/IP通讯协议之上，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。

HTTP协议主要工作于B-S架构之上，这个时候浏览器作为HTTP的客户端通过URL向HTTP的服务器（web服务器）发送所有请求，web服务器根据接收到的请求后，向客户端发送响应信息。

客户端向服务器请求发送时，需要传送请求方法和路径。路径就是URL，而HTTP常用的请求方法为GET和POST方法，每种方法规定了客户端与服务器通讯方式和数据报文。

### HTTP协议的特点？

1. HTTP允许传输**任意类型**的数据。传输的类型由Content-Type加以标记。
2. **无状态**。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系。
3. 支持**客户端/服务器模式**。

### HTTP报文格式

HTTP请求由**请求行、请求头部、空行和请求体**四个部分组成。

- **请求行**：包括请求方法，访问的资源URL，使用的HTTP版本。`GET`和`POST`是最常见的HTTP方法，除此以外还包括`DELETE、HEAD、OPTIONS、PUT、TRACE`。
- **请求头**：格式为“属性名:属性值”，服务端根据请求头获取客户端的信息，主要有`cookie、host、connection、accept-language、accept-encoding、user-agent`。
- **请求体**：用户的请求数据如用户名，密码等。

![image-20230926221340281](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926221340281.png)

![image-20230926221405497](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926221405497.png)

**请求报文示例**：

```java
POST /xxx HTTP/1.1 请求行
Accept:image/gif.image/jpeg, 请求头部
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate

username=dabin 请求体
```

HTTP响应也由四个部分组成，分别是：**状态行、响应头、空行和响应体**。

- **状态行**：协议版本，状态码及状态描述。
- **响应头**：响应头字段主要有`connection、content-type、content-encoding、content-length、set-cookie、Last-Modified，、Cache-Control、Expires`。
- **响应体**：服务器返回给客户端的内容。

**响应报文示例**：

```html
HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

<html>
    <body>响应体</body>
</html>
```

### HTTP状态码有哪些？

![image-20230926003855462](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926003855462.png)

### HTTP协议包括哪些请求？

HTTP协议中共定义了八种方法来表示对Request-URI指定的资源的不同操作方式，具体如下：

- GET：向特定的资源发出请求。
- POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。
- OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
- HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。
- PUT：向指定资源位置上传其最新内容。
- DELETE：请求服务器删除Request-URI所标识的资源。
- TRACE：回显服务器收到的请求，主要用于测试或诊断。
- CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

### HTTP状态码301和302的区别？

- 301：（永久性转移）请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。
- 302：（暂时性转移）服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。

**举个形象的例子**：当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，打个比方说，我有一套房子，但是最近走亲戚去亲戚家住了，过两天我还回来的。而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的，就比如你的那套房子其实是租的，现在租期到了，你又在另一个地方找到了房子，之前租的房子不住了。

### URI和URL的区别？

- URI，全称是Uniform Resource Identifier，中文翻译是统一资源标志符，主要作用是唯一标识一个资源。
- URL，全称是Uniform Resource Location，中文翻译是统一资源定位符，主要作用是提供资源的路径。打个经典比喻吧，URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。

### GET和POST的区别？

- GET请求参数通过URL传递，POST的参数放在请求体中。
- GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把请求头和请求体一并发送出去；而对于POST，浏览器先发送请求头，服务器响应100 continue，浏览器再发送请求体。
- GET请求会被浏览器主动缓存，而POST不会，除非手动设置。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

### 如何理解HTTP协议是无状态的？

当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。简言之，服务器不会去记住你是谁，所以是无状态协议。

### HTTP长连接和短连接？

HTTP短连接：浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。**HTTP1.0默认使用的是短连接**。

HTTP长连接：指的是**复用TCP连接**。多个HTTP请求可以复用同一个TCP连接，这就节省了TCP连接建立和断开的消耗。

**HTTP/1.1起，默认使用长连接**。要使用长连接，客户端和服务器的HTTP首部的Connection都要设置为keep-alive，才能支持长连接。

### HTTP如何实现长连接？

HTTP分为长连接和短连接，**本质上说的是TCP的长短连接**。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才具有真正的长连接和短连接这一说法哈。

TCP长连接可以复用一个TCP连接，来发起多次的HTTP请求，这样就可以减少资源消耗，比如一次请求HTML，如果是短连接的话，可能还需要请求后续的JS/CSS。

**如何设置长连接？**

通过在头部（请求和响应头）设置**Connection**字段指定为`keep-alive`，HTTP/1.0协议支持，但是是默认关闭的，从HTTP/1.1以后，连接默认都是长连接。

### HTTP长连接在什么时候会超时？

HTTP一般会有httpd守护进程，里面可以设置**keep-alive timeout**，当tcp连接闲置超过这个时间就会关闭，也可以在HTTP的header里面设置超时时间。

TCP 的**keep-alive**包含三个参数，支持在系统内核的net.ipv4里面设置；当 TCP 连接之后，闲置了**tcp_keepalive_time**，则会发生侦测包，如果没有收到对方的ACK，那么会每隔 tcp_keepalive_intvl再发一次，直到发送了**tcp_keepalive_probes**，就会丢弃该连接。

### HTTP1.1和HTTP2.0的区别？

HTTP2.0相比HTTP1.1支持的特性：

- **新的二进制格式**：HTTP1.1 基于文本格式传输数据；HTTP2.0采用二进制格式传输数据，解析更高效。
- **多路复用**：在一个连接里，允许同时发送多个请求或响应，**并且这些请求或响应能够并行的传输而不被阻塞**，避免 HTTP1.1 出现的”队头堵塞”问题。
- **头部压缩**，HTTP1.1的header带有大量信息，而且每次都要重复发送；HTTP2.0 把header从数据中分离，并封装成头帧和数据帧，**使用特定算法压缩头帧**，有效减少头信息大小。并且HTTP2.0**在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。**比如请求a发送了所有的头信息字段，请求b则**只需要发送差异数据**，这样可以减少冗余数据，降低开销。
- **服务端推送**：HTTP2.0允许服务器向客户端推送资源，无需客户端发送请求到服务器获取

### HTTPS和HTTP的区别？

1. HTTP是超文本传输协议，信息是**明文传输**；HTTPS则是具有**安全性**的SSL加密传输协议。
2. HTTP和HTTPS用的端口不一样，HTTP端口是80，HTTPS是443。
3. HTTPS协议**需要到CA机构申请证书**，一般需要一定的费用。
4. HTTP运行在TCP协议之上；HTTPS运行在SSL协议之上，SSL运行在TCP协议之上。

### HTTPS原理

首先是TCP三次握手，然后客户端发起一个HTTPS连接建立请求，客户端先发一个`Client Hello`的包，然后服务端响应`Server Hello`，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。

**协商加密算法** 。在`Client Hello`里面客户端会告知服务端自己当前的一些信息，包括客户端要使用的TLS版本，支持的加密算法，要访问的域名，给服务端生成的一个随机数（Nonce）等。需要提前告知服务器想要访问的域名以便服务器发送相应的域名的证书过来。

![image-20230926222538100](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926222538100.png)

服务端响应`Server Hello`，告诉客户端服务端**选中的加密算法**。

![image-20230926222606337](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926222606337.png)

接着服务端给客户端发来了2个证书。第二个证书是第一个证书的签发机构（CA）的证书。

![image-20230926222635328](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926222635328.png)

客户端使用证书的认证机构CA公开发布的RSA公钥**对该证书进行验证**，下图表明证书认证成功。

![image-20230926222658332](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926222658332.png)

验证通过之后，浏览器和服务器通过**密钥交换算法**产生共享的**对称密钥**。

![image-20230926222730082](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926222730082.png)

开始传输数据，使用同一个对称密钥来加解密。

![image-20230926222750734](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926222750734.png)

### 浏览器中输入URL返回页面的过程

1. **解析域名**，找到主机 IP。
2. 浏览器利用 IP 直接与网站主机通信，**三次握手**，建立 TCP 连接。浏览器会以一个随机端口向服务端的 web 程序 80 端口发起 TCP 的连接。
3. 建立 TCP 连接后，浏览器向主机发起一个HTTP请求。
4. 服务器**响应请求**，返回响应数据。
5. 浏览器**解析响应内容，进行渲染**，呈现给用户。

![image-20230926224210000](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230926224210000.png)

### 什么是cookie和session？

**Cookie：**

1. **工作原理**：Cookie是一个小的文本文件，由Web服务器发送给用户的浏览器，然后存储在用户的计算机上。每次用户访问相同的网站时，浏览器都会将这个Cookie发送回服务器，从而允许服务器识别和跟踪用户。
2. **持久性**：Cookie可以具有持久性，可以设置过期时间，允许数据在多次访问之间保留。但也可以创建会话Cookie，它们在用户关闭浏览器时被删除。
3. **用途**：Cookie通常用于跟踪用户会话、存储用户首选项、购物车内容以及用于广告追踪和分析等。
4. **安全性**：Cookie中的数据可以被客户端查看和修改，因此不适合存储敏感信息，如密码。

**Session：**

1. **工作原理**：Session是一种服务器端的机制，用于在用户与服务器之间保持状态信息。当用户首次访问网站时，服务器会为每个用户创建一个唯一的会话，并分配一个会话ID。这个会话ID通常存储在Cookie中或通过URL参数传递给客户端，以便在后续请求中识别用户。
2. **持久性**：Session数据通常不是持久性的，它们在用户关闭浏览器或一段时间不活动后会被销毁。
3. **用途**：Session通常用于管理用户的登录状态，存储用户在一次会话期间的临时数据，如购物车内容，以及其他需要保持在服务器上的状态信息。
4. **安全性**：由于Session数据存储在服务器上，因此相对于Cookie来说更安全，不容易被客户端修改。

### cookie和session的区别？

- **作用范围不同**，Cookie 保存在客户端，Session 保存在服务器端。
- **有效期不同**，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
- **隐私策略不同**，Cookie 存储在客户端，容易被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
- **存储大小不同**， 单个 Cookie 保存的数据不能超过 4K；对于 Session 来说存储没有上限，但出于对服务器的性能考虑，Session 内不要存放过多的数据，并且需要设置 Session 删除机制。

## 操作系统

### 进程和线程的区别？

调度：进程是资源管理的基本单位，线程是程序执⾏的基本单位。

切换：线程上下⽂切换⽐进程上下⽂切换要快得多。

拥有资源：进程是拥有资源的⼀个独⽴单位，线程不拥有系统资源，但是可以访问⾪属于进程的资源。 

系统开销：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O 设备等，OS所付出的 开销显著⼤于在创建或撤销线程时的开销，进程切换的开销也远⼤于线程切换的开销。

### 线程和协程的区别？

线程和进程都是同步机制，⽽协程是异步机制。 

线程是抢占式，⽽协程是⾮抢占式的。需要⽤户释放使⽤权切换到其他协程，因此同⼀时间其实只有⼀个协程 拥有运⾏权，相当于单线程的能⼒。

 ⼀个线程可以有多个协程，⼀个进程也可以有多个协程。 

协程不被操作系统内核管理，⽽完全是由程序控制。线程是被分割的 CPU 资源，协程是组织好的代码流程， 线程是协程的资源。但协程不会直接使⽤线程，协程直接利⽤的是执⾏器关联任意线程或线程池。

协程能保留上⼀次调⽤时的状态。

### 并发和并行的区别？

并发就是在⼀段时间内，多个任务都会被处理；但在某⼀时刻，只有⼀个任务在执⾏。单核处理器可以做到并发。

并⾏就是在同⼀时刻，有多个任务在执⾏。这个需要多核处理器才能完成。

### 进程间通信方式有哪些？

管道：管道这种通讯⽅式有两种限制，⼀是半双⼯的通信，数据只能单向流动，⼆是只能在具有亲缘关系的进程间 使⽤。进程的亲缘关系通常是指⽗⼦进程关系。

 管道可以分为两类：匿名管道和命名管道。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道以磁盘 ⽂件的⽅式存在，可以实现本机任意两个进程通信。

 信号：信号是⼀种⽐较复杂的通信⽅式，信号可以在任何时候发给某⼀进程，⽽⽆需知道该进程的状态。

 Linux 系统中常⽤信号：

 1）SIGHUP：⽤户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终⽌进 程。

 2）SIGINT：程序终⽌信号。程序运⾏过程中，按 Ctrl+C 键将产⽣该信号。 3）SIGQUIT：程序退出信号。程序运⾏过程中，按 Ctrl+\键将产⽣该信号。4）SIGBUS和 SIGSEGV：进程 访问⾮法地址。

 5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。

 6）SIGKILL：⽤户终⽌进程执⾏信号。shell 下执⾏ kill -9 发送该信号。 7）SIGTERM：结束进程信号。shell 下执⾏ kill 进程 pid 发送该信号。

 8）SIGALRM：定时器信号。

 9）SIGCLD：⼦进程退出信号。如果其⽗进程没有忽略该信号也没有处理该信号，则⼦进程退出后将形成僵 ⼫进程。

 信号量：信号量是⼀个计数器，可以⽤来控制多个进程对共享资源的访问。它常作为⼀种锁机制，防⽌某进程 正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同⼀进程内不同线程之间的同步⼿段。 

消息队列：消息队列是消息的链接表，包括 Posix 消息队列和 System V 消息队列。有⾜够权限的进程可以向 队列中添加消息，被赋予读权限的进程则可以读⾛队列中的消息。消息队列克服了信号承载信息量少，管道只 能承载⽆格式字节流以及缓冲区⼤⼩受限等缺点。 

共享内存：共享内存就是映射⼀段能被其他进程所访问的内存，这段共享内存由⼀个进程创建，但多个进程都 可以访问。共享内存是最快的 IPC ⽅式，它是针对其他进程间通信⽅式运⾏效率低⽽专⻔设计的。它往往与 其他通信机制，如信号量，配合使⽤，来实现进程间的同步和通信。

 Socket：与其他通信机制不同的是，它可⽤于不同机器间的进程通信。

 优缺点：

 管道：速度慢，容量有限；

 Socket：任何进程间都能通讯，但速度慢； 

消息队列：容量受到系统限制，且要注意第⼀次读的时候，要考虑上⼀次没有读完数据的问题；

 信号量：不能传递复杂消息，只能⽤来同步； 

共享内存区：能够很容易控制容量，速度快，但要保持同步，⽐如⼀个进程在写的时候，另⼀个进程要注意读 写的问题，相当于线程中的线程安全，当然，共享内存区同样可以⽤作线程间通讯，不过没这个必要，线程间 本来就已经共享了同⼀进程内的⼀块内存。

### 进程间同步的方式有哪些？

临界区：通过对多线程的串⾏化来访问公共资源或⼀段代码，速度快，适合控制数据访问。

优点：保证在某⼀时刻只有⼀个线程能访问数据的简便办法。

缺点：虽然临界区同步速度很快，但却只能⽤来同步 本进程内的线程，⽽不可⽤来同步多个进程中的线程。 

互斥量： 为协调共同对⼀个共享资源的单独访问⽽设计的。互斥量跟临界区很相似，⽐临界区复杂，互斥对象只有⼀个，只 有拥有互斥对象的线程才具有访问资源的权限。

优点：使⽤互斥不仅仅能够在同⼀应⽤程序不同线程中实现资源的 安全共享，⽽且可以在不同应⽤程序的线程之间实现对资源的安全共享。

 缺点：

互斥量是可以命名的，也就是说它可以跨越进程使⽤，所以创建互斥量需要的资源更多，所以如果只为了在进 程内部是⽤的话使⽤临界区会带来速度上的优势并能够减少资源占⽤量。 

通过互斥量可以指定资源被独占的⽅式使⽤，但如果有下⾯⼀种情况通过互斥量就⽆法处理，⽐如现在⼀位⽤ 户购买了⼀份三个并发访问许可的数据库系统，可以根据⽤户购买的访问许可数量来决定有多少个线程/进程 能同时进⾏数据库操作，这时候如果利⽤互斥量就没有办法完成这个要求，信号量对象可以说是⼀种资源计数 器。

 信号量：为控制⼀个具有有限数量⽤户资源⽽设计。它允许多个线程在同⼀时刻访问同⼀资源，但是需要限制在同 ⼀时刻访问此资源的最⼤线程数⽬。互斥量是信号量的⼀种特殊情况，当信号量的最⼤资源数=1就是互斥量了。优 点：适⽤于对 Socket（套接字）程序中线程的同步。

缺点: 信号量机制必须有公共内存，不能⽤于分布式操作系统，这是它最⼤的弱点； 信号量机制功能强⼤，但使⽤时对信号量的操作分散，⽽且难以控制，读写和维护都很困难，加重了程序员的 编码负担； 核⼼操作 P-V分散在各⽤户程序的代码中，不易控制和管理，⼀旦错误，后果严重，且不易发现和纠正。 

事件：⽤来通知线程有⼀些事件已发⽣，从⽽启动后继任务的开始。 优点：事件对象通过通知操作的⽅式来保持线程的同步，并且可以实现不同进程中的线程同步操作。

### 线程同步的方式有哪些？

临界区：当多个线程访问⼀个独占性共享资源时，可以使⽤临界区对象。拥有临界区的线程可以访问被保护起来的 资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为⽌，以此达到⽤原⼦⽅式操作 共享资源的⽬的。

事件：事件机制，则允许⼀个线程在处理完⼀个任务后，主动唤醒另外⼀个线程执⾏任务。互斥量：互斥对象和临 界区对象⾮常相似，只是其允许在进程间使⽤，⽽临界区只限制与同⼀进程的各个线程之间使⽤，但是更节省资 源，更有效率。信号量：当需要⼀个计数器来限制可以使⽤某共享资源的线程数⽬时，可以使 ⽤“信号量”对象。 

区别： 互斥量与临界区的作⽤⾮常相似，但互斥量是可以命名的，也就是说互斥量可以跨越进程使⽤，但创建互斥量 需要的资源更多，所以如果只为了在进程内部是⽤的话使⽤临界区会带来速度上的优势并能够减少资源占⽤ 量。因为互斥量是跨进程的互斥量⼀旦被创建，就可以通过名字打开它。

互斥量，信号量，事件都可以被跨越进程使⽤来进⾏同步数据操作。

### 什么是临界区，如何解决冲突？

每个进程中访问临界资源的那段程序称为临界区，⼀次仅允许⼀个进程使⽤的资源称为临界资源。 

解决冲突的办法： 如果有若⼲进程要求进⼊空闲的临界区，⼀次仅允许⼀个进程进⼊，如已有进程进⼊⾃⼰的临界区，则其它所 有试图进⼊临界区的进程必须等待； 进⼊临界区的进程要在有限时间内退出。 如果进程不能进⼊⾃⼰的临界区，则应让出 CPU，避免进程出现“忙等”现象

### 什么是死锁？死锁产⽣的条件

什么是死锁：在两个或者多个并发进程中，如果每个进程持有某种资源⽽⼜等待其它进程释放它或它们现在保持着 的资源，在未改变这种状态之前都不能向前推进，称这⼀组进程产⽣了死锁。通俗的讲就是两个或多个进程⽆限期 的阻塞、相互等待的⼀种状态。 

死锁产⽣的四个必要条件：（有⼀个条件不成⽴，则不会产⽣死锁）

 互斥条件：⼀个资源⼀次只能被⼀个进程使⽤ 

请求与保持条件：⼀个进程因请求资源⽽阻塞时，对已获得资源保持不放 

不剥夺条件：进程获得的资源，在未完全使⽤完之前，不能强⾏剥夺 

循环等待条件：若⼲进程之间形成⼀种头尾相接的环形等待资源关系

如何处理死锁问题： 

检测死锁并且恢复。 仔细地对资源进⾏动态分配，以避免死锁。 通过破除死锁四个必要条件之⼀，来防⽌死锁产⽣。

### 进程调度策略有哪几种

先来先服务：⾮抢占式的调度算法，按照请求的顺序进⾏调度。有利于⻓作业，但不利于短作业，因为短作业 必须⼀直等待前⾯的⻓作业执⾏完毕才能执⾏，⽽⻓作业⼜需要执⾏很⻓时间，造成了短作业等待时间过⻓。 另外，对 I/O 密集型进程也不利，因为这种进程每次进⾏ I/O 操作之后⼜得重新排队。 

短作业优先：⾮抢占式的调度算法，按估计运⾏时间最短的顺序进⾏调度。⻓作业有可能会饿死，处于⼀直等 待短作业执⾏完毕的状态。因为如果⼀直有短作业到来，那么⻓作业永远得不到调度。 

最短剩余时间优先：最短作业优先的抢占式版本，按剩余运⾏时间的顺序进⾏调度。当⼀个新的作业到达时， 其整个运⾏时间与当前进程的剩余时间作⽐较。如果新的进程需要的时间更少，则挂起当前进程，运⾏新的进 程。否则新的进程等待。 

时间⽚轮转：将所有就绪进程按 FCFS的原则排成⼀个队列，每次调度时，把 CPU时间分配给队⾸进程，该进程可 以执⾏⼀个时间⽚。当时间⽚⽤完时，由 计时器发出时钟中断，调度程序便停⽌该进程的执⾏，并将它送往就绪队列的末尾，同时继续把 CPU时间分配给队 ⾸的进程。

 时间⽚轮转算法的效率和时间⽚的⼤⼩有很⼤关系：因为进程切换都要保存进程的信息并且载⼊新进程的信 息，如果时间⽚太⼩，会导致进程切换得太频繁，在进程切换上就会花过多时间。⽽如果时间⽚过⻓，那么实 时性就不能得到保证。 优先级调度：为每个进程分配⼀个优先级，按优先级进⾏调度。为了防⽌低优先级的进程永远等不到调度，可 以随着时间的推移增加等待进程的优先级

### 进程有哪些状态？

进程⼀共有5 种状态，分别是创建、就绪、运⾏（执⾏）、终⽌、阻塞。

运⾏状态就是进程正在 CPU上运⾏。在单处理机环境下，每⼀时刻最多只有⼀个进程处于运⾏状态。 

就绪状态就是说进程已处于准备运⾏的状态，即进程获得了除 CPU之外的⼀切所需资源，⼀旦得到 CPU即可 运⾏。 

阻塞状态就是进程正在等待某⼀事件⽽暂停运⾏，⽐如等待某资源为可⽤或等待 I/O 完成。即使 CPU空闲， 该进程也不能运⾏。 

运⾏态→阻塞态：往往是由于等待外设，等待主存等资源分配或等待⼈⼯⼲预⽽引起的。 

阻塞态→就绪态：则是等待的条件已满⾜，只需分配到处理器后就能运⾏。 运⾏态→就绪态：不是由于⾃身原因，⽽是由外界原因使运⾏状态的进程让出处理器，这时候就变成就绪态。例如 时间⽚⽤完，或有更⾼优先级的进程来抢占处理器等。 

就绪态→运⾏态：系统按某种策略选中就绪队列中的⼀个进程占⽤处理器，此时就变成了运⾏态。

### 什么是分页

把内存空间划分为⼤⼩相等且固定的块，作为主存的基本单位。因为程序数据存储在不同的⻚⾯中，⽽⻚⾯⼜离散 的分布在内存中，因此需要⼀个⻚表来记录映射关系，以实现从⻚号到物理块号的映射。访问分⻚系统中内存数据 需要两次的内存访问(⼀次是从内存中访问⻚表，从中找到指定的物理块号，加上⻚内偏移得到实际物理地址；第⼆ 次就是根据第⼀次得到的物理地址访问内存取出数据)

### 什么是分段

分⻚是为了提⾼内存利⽤率，⽽分段是为了满⾜程序员在编写代码的时候的⼀些逻辑需求(⽐如数据共享，数据保 护，动态链接等)。分段内存管理当中，地址是⼆维的，⼀维是段号，⼆维是段内地址；其中每个段的⻓度是不⼀样 的，⽽且每个段内部都是从0 开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散 分配的，因此也存在⼀个逻辑地址到物理地址的映射关系，相应的就是段表机制

### 分页和分段的区别

分⻚对程序员是透明的，但是分段需要程序员显式划分每个段。 分⻚的地址空间是⼀维地址空间，分段是⼆维的。 ⻚的⼤⼩不可变，段的⼤⼩可以动态改变。 分⻚主要⽤于实现虚拟内存，从⽽获得更⼤的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独 ⽴的地址空间并且有助于共享和保护

### 什么是交换空间

操作系统把物理内存(physical RAM)分成⼀块⼀块的⼩内存，每⼀块内存被称为⻚(page)。当内存资源不⾜时， Linux 把某些⻚的内容转移⾄硬盘上的⼀块空间上，以释放内存空间。硬盘上的那块空间叫做交换空间(swap space),⽽这⼀过程被称为交换(swapping)。物理内存和交换空间的总容量就是虚拟内存的可⽤容量。 

⽤途： 物理内存不⾜时⼀些不常⽤的⻚可以被交换出去，腾给系统。 程序启动时很多内存⻚被⽤来初始化，之后便不再需要，可以交换出去

### 页面替换算法

1. **先进先出（FIFO）：** 这是最简单的页面替换算法，它选择最早进入物理内存的页面进行替换。然而，FIFO算法可能导致"Belady现象"，即增加页面数量时缺页率反而上升。
2. **最近最少使用（LRU）：** LRU算法选择最近最少使用的页面进行替换。它需要维护一个访问页面的顺序，以确保总是选择最长时间未使用的页面。
3. **最不常用（LFU）：** LFU算法选择被引用最少次数的页面进行替换。它需要跟踪每个页面的引用次数。
4. **最佳替换（OPT）：** 最佳替换算法选择未来使用时间最远的页面进行替换。尽管是一种理想情况下的算法，但在实践中难以实现，因为需要预测未来的页面访问模式。
5. **时钟替换（Clock）：** 时钟替换算法维护一个环形缓冲区，页面按照固定的顺序排列，被替换的页面是"指针"指向的页面，如果页面被访问，则将其标记并将指针向前移动。替换时找到第一个未被标记的页面进行替换。
6. **最近未使用（NRU）：** NRU算法按照页面的访问情况和修改状态分为4个类别，然后从类别中选择要替换的页面。这是一个相对简单的算法。
7. **二次机会替换（Second Chance）：** 二次机会替换算法是时钟替换的变体，它允许被标记的页面有第二次机会不被替换。
8. **工作集替换（Working Set）：** 工作集算法根据每个页面的工作集大小来选择替换的页面。工作集是进程在一段时间内访问的页面集合。

### 什么是缓冲区溢出？有什么危害？

缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。 

危害有以下两点： 程序崩溃，导致拒绝额服务 

跳转并且执⾏⼀段恶意代码造成缓冲区溢出的主要原因是程序中没有仔细检查⽤户输⼊。

### 什么是虚拟内存？

虚拟内存就是说，让物理内存扩充成更⼤的逻辑内存，从⽽让程序获得更多的可⽤内存。虚拟内存使⽤部分加载的 技术，让⼀个进程或者资源的某些⻚⾯加载进内存，从⽽能够加载更多的进程，甚⾄能加载⽐内存⼤的进程，这样 看起来好像内存变⼤了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存

### 什么是IO多路复用

IO多路复⽤是指内核⼀旦发现进程指定的⼀个或者多个 IO条件准备读取，它就通知该进程。IO多路复⽤适⽤如下 场合： 

当客户处理多个描述字时（⼀般是交互式输⼊和⽹络套接⼝），必须使⽤ I/O 复⽤。 

当⼀个客户同时处理多个套接⼝时，⽽这种情况是可能的，但很少出现。

如果⼀个 TCP服务器既要处理监听套接⼝，⼜要处理已连接套接⼝，⼀般也要⽤到 I/O 复⽤。 

如果⼀个服务器即要处理 TCP，⼜要处理 UDP，⼀般要使⽤ I/O 复⽤。

如果⼀个服务器要处理多个服务或多个协议，⼀般要使⽤ I/O 复⽤。 

与多进程和多线程技术相⽐，I/O 多路复⽤技术的最⼤优势是系统开销⼩，系统不必创建进程/线程，也不必 维护这些进程/线程，从⽽⼤⼤减⼩了系统的开销

### 硬链接和软链接的区别

硬链接就是在⽬录下创建⼀个条⽬，记录着⽂件名与 inode 编号，这个 inode 就是源⽂件的 inode。删除任意⼀个条⽬，⽂件还是存在，只要引⽤数量不为0。但是硬链接有限制，它不能跨越⽂件系统，也不能对⽬录 进⾏链接。 

符号链接⽂件保存着源⽂件所在的绝对路径，在读取时会定位到源⽂件上，可以理解为 Windows的快捷⽅ 式。当源⽂件被删除了，链接⽂件就打不开了。因为记录的是路径，所以可以为⽬录建⽴符号链接。

### 中断处理过程

保护现场：将当前执⾏程序的相关数据保存在寄存器中，然后⼊栈。 

开中断：以便执⾏中断时能响应较⾼级别的中断请求。 

中断处理 

关中断：保证恢复现场时不被新中断打扰 

恢复现场：从堆栈中按序取出程序数据，恢复中断前的执⾏状态。

### 中断和轮询有什么区别？

轮询：CPU对特定设备轮流询问。中断：通过特定事件提醒 CPU。 

轮询：效率低等待时间⻓，CPU利⽤率不⾼。中断：容易遗漏问题，CPU利⽤率不⾼。

## MySQL和Redis高频

### redis和mysql的区别，怎么协同合作的

1. **Redis**:
   - Redis是一种内存存储数据库，用于快速读写访问数据。
   - 它通常用于缓存数据，会话存储，消息队列，实时分析等需要高性能、低延迟的应用。
   - Redis支持多种数据结构，如字符串、哈希、列表、集合、有序集合等。
   - Redis是单线程的，这意味着它在处理请求时是原子性的，不需要考虑并发问题。
   - 数据通常不持久保存在硬盘上，因此不适用于需要数据持久性的应用。
2. **MySQL**:
   - MySQL是一种关系型数据库管理系统（RDBMS），用于存储结构化数据。
   - 它适用于需要复杂查询和事务支持的应用，如电子商务、金融系统等。
   - MySQL使用SQL语言进行数据操作，支持ACID事务。
   - 数据通常持久保存在硬盘上，确保数据的持久性和一致性。

协同合作的方式：

1. **缓存层**：Redis可以用作MySQL的缓存层，加速读取操作。当数据在MySQL中发生更改时，需要更新Redis中的缓存数据，以确保数据的一致性。这可以提高访问速度，减轻MySQL的负担。
2. **消息队列**：Redis可以用作消息队列，用于异步任务处理。你可以将任务放入Redis队列中，然后由后台工作者处理这些任务。这可以减少Web应用的响应时间，因为任务不必立即执行。
3. **分布式锁**：Redis可以用于实现分布式锁，以协调多个应用程序实例的访问共享资源的顺序。
4. **实时分析**：Redis可以用于实时数据分析，将数据存储在Redis中，然后由分析工具进行实时处理。

### 如何设计一个框架将MySQL表自动同步到Redis中

1. **数据触发**：数据同步可以通过MySQL触发器实时触发，或者定时任务轮询数据库。
2. **数据映射**：定义如何将MySQL表数据映射到Redis数据结构，如哈希表、列表等。
3. **连接配置**：配置MySQL和Redis连接信息，包括主机、端口、认证。
4. **同步逻辑**：编写同步逻辑，查询MySQL数据并将其同步到Redis中。
5. **异常处理**：处理同步过程中的异常情况，记录错误信息并采取适当措施。
6. **性能优化**：考虑性能问题，如批量操作、数据压缩等，以降低同步开销。
7. **数据一致性**：确保数据在MySQL和Redis之间保持一致，处理同步失败情况。
8. **部署和监控**：部署框架并设置监控，追踪同步性能和数据一致性。
9. **测试**：进行充分的测试，包括单元测试、集成测试和性能测试。

### MySQL和Redis之间如何保持数据的一致性和安全性

**有序操作：** 确保在更新MySQL和Redis之前，先执行MySQL的写操作，然后再更新Redis。这可以确保Redis中的数据与MySQL保持一致。

**2. 数据同步策略：** 实现一个数据同步策略，确保MySQL和Redis的数据保持同步。可以使用定时任务或事件触发机制，定期将MySQL数据同步到Redis中。

**3. 事务（Transaction）：** 对于某些需要强一致性的操作，可以使用MySQL的事务机制。这允许你在一个事务中执行多个操作，要么全部成功，要么全部失败，以确保一致性。

**4. 数据验证：** 在将数据从MySQL同步到Redis之前，可以先验证数据的完整性和准确性。这可以通过在MySQL中执行检查操作，然后再同步到Redis来实现。

**5. 异常处理：** 设计一套异常处理机制，以应对可能发生的同步错误或故障。当同步失败时，确保有合适的日志记录和错误处理，以便快速识别和修复问题。

**6. 安全访问控制：** 针对Redis和MySQL都实施访问控制和安全措施。使用密码、认证、防火墙等来限制对数据库的访问。

**7. 数据加密：** 在数据传输和存储阶段使用加密来保护数据的机密性。使用SSL/TLS来加密数据传输，以及数据加密算法来加密存储在Redis中的敏感数据。

**8. 数据备份和恢复：** 定期备份MySQL和Redis的数据，以便在灾难恢复时使用。确保备份数据的安全存储，并测试备份恢复流程。

**9. 安全漏洞修复：** 定期更新MySQL和Redis的版本以修复已知的安全漏洞。保持软件更新，以减少潜在的攻击风险。

**10. 监控和警报：** 实施监控和警报系统，以监视数据库的性能和安全。在异常事件发生时能够及时通知管理员。

### 缓存穿透、缓存雪崩、缓存击穿

**缓存穿透**，是指在使用缓存时，由于某个请求所需的数据在缓存中不存在，导致这个请求穿透缓存，直接查询数据库或其他数据存储，从而引起大量请求直接击中底层存储系统，导致数据库或数据存储的负载急剧增加，甚至可能引发性能问题。 

如何解决 有两种⽅案可以解决： 

⽅案⼀，缓存空对象。 当从 DB 查询数据为空，我们仍然将这个空结果进⾏缓存，具体的值需要使⽤特殊的标识，能和真正缓存的数据区 分开。另外，需要设置较短的过期时间，⼀般建议不要超过5 分钟。

 ⽅案⼆，BloomFilter 布隆过滤器。 在缓存服务的基础上，构建 BloomFilter 数据结构，在 BloomFilter 中存储对应的 KEY 是否存在，如果存在，说明 该 KEY 对应的值不为空。

**缓存雪崩**，是指指缓存由于某些原因⽆法提供服务(例如，缓存挂掉了)，所有请求全部达到 DB 中，导致 DB 负荷⼤ 增，最终挂掉的情况

预防和解决缓存雪崩的问题，可以从以下多个⽅⾯进⾏共同着⼿。

 1）缓存⾼可⽤：通过搭建缓存的⾼可⽤，避免缓存挂掉导致⽆法提供服务的情况，从⽽降低出现缓存雪崩的情 况。假设我们使⽤ Redis 作为缓存，则可以使⽤ Redis Sentinel 或 Redis Cluster 实现⾼可⽤。 

2）本地缓存：如果使⽤本地缓存时，即使分布式缓存挂了，也可以将 DB 查询到的结果缓存到本地，避免后续请 求全部到达 DB 中。如果我们使⽤ JVM ，则可以使⽤ Ehcache、Guava Cache 实现本地缓存的功能

**缓存击穿**，是指某个极度“热点”数据在某个时间点过期时，恰好在这个时间点对这个 KEY 有⼤量的并发请求过来， 这些请求发现缓存过期⼀般都会从 DB 加载数据并回设到缓存，但是这个时候⼤并发的请求可能会瞬间 DB 压垮。

解决方案：

有两种⽅案可以解决：

 1）⽅案⼀，使⽤互斥锁。请求发现缓存不存在后，去查询 DB 前，使⽤分布式锁，保证有且只有⼀个线程去查询 DB ，并更新到缓存。 

2）⽅案⼆，⼿动过期。缓存上从不设置过期时间，功能上将过期时间存在 KEY 对应的 VALUE ⾥。流程如下： 

1、获取缓存。通过 VALUE 的过期时间，判断是否过期。如果未过期，则直接返回；如果已过期，继续往下 执⾏。 

2、通过⼀个后台的异步线程进⾏缓存的构建，也就是“⼿动”过期。通过后台的异步线程，保证有且只有⼀个 线程去查询 DB。 

3、同时，虽然 VALUE 已经过期，还是直接返回。通过这样的⽅式，保证服务的可⽤性，虽然损失了⼀定的 时效性

### Redis回收策略

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使⽤的数据淘汰 

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使⽤的数据淘汰 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 

no-enviction（驱逐）：禁⽌驱逐数据

### Redis持久化机制？各自优缺点？

Redis 提供两种持久化机制 RDB 和 AOF 机制： RDBRedis DataBase)持久化⽅式： 

RDB是指⽤数据集快照的⽅式半持久化模式)记录 redis 数据库的所有键值对,在某个时间点将数据写⼊⼀个临时⽂件， 持久化结束后，⽤这个临时⽂件替换上次持久化的⽂件，达到数据恢复。 

优点： 只有⼀个⽂件 dump.rdb，⽅便持久化。

 容灾性好，⼀个⽂件可以保存到安全的磁盘。 

性能最⼤化，fork ⼦进程来完成写操作，让主进程继续处理命令，所以 是 IO 最⼤化。使⽤单独⼦进程来进⾏持久化，主进程不会进⾏任何 IO 操作，保证了 redis 的⾼性能) 

相对于数据集⼤时，⽐ AOF 的启动效率更⾼。 

缺点： 数据安全性低。RDB 是间隔⼀段时间进⾏持久化，如果持久化之间 redis 发⽣故障，会发⽣数据丢失。所以这种⽅ 式更适合数据要求不严谨的时候。 

AOF （Append-only file)持久化⽅式： 是指所有的命令⾏记录以 redis 命令请求协议的格式完全持久化存储)保存为 aof ⽂件。 

优点： 数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进⾏⼀次命令操作就记录到 aof ⽂件中⼀ 次。 通过 append 模式写⽂件，即使中途服务器宕机，可以通过 redis- check-aof ⼯具解决数据⼀致性问题。 AOF 机制的 rewrite 模式。AOF ⽂件没被 rewrite 之前（⽂件过⼤时会对命令进⾏合并重写），可以删除其 中的某些命令（⽐如误操作的 flushall）) 

缺点： AOF ⽂件⽐ RDB ⽂件⼤，且恢复速度慢。 数据集⼤的时候，⽐ rdb 启动效率低。

### MySQL的慢查询如何优化？

1. **使用索引**：
   - 确保查询中的字段在表上建有适当的索引。索引可以显著加速查询速度。
2. **优化查询语句**：
   - 分析慢查询日志，查找慢查询语句，并尝试重写它们以更有效率。使用`EXPLAIN`来检查查询执行计划，以查找潜在的性能问题。
3. **避免全表扫描**：
   - 尽量避免执行全表扫描，特别是对大表。使用索引或限制结果集以加速查询。
4. **使用合适的数据类型**：
   - 使用适当的数据类型来存储数据，避免使用过大的数据类型。这可以减小存储空间和提高查询性能。
5. **分页查询**：
   - 当需要分页查询大量数据时，使用`LIMIT`来限制结果集，而不是将所有数据一次性检索出来。
6. **缓存查询结果**：
   - 对于不经常变化的查询结果，可以考虑使用缓存来减轻数据库负载。
7. **定期优化表**：
   - 定期运行`OPTIMIZE TABLE`以优化表的性能，特别是对于频繁更新或删除数据的表。
8. **垂直分割表**：
   - 将大表拆分为多个小表，根据查询需求来分割，以提高性能。
9. **水平分区**：
   - 如果表非常大，可以考虑水平分区，将数据分散到多个物理存储中。
10. **调整缓冲池**：
    - 调整MySQL的缓冲池大小，如`innodb_buffer_pool_size`和`key_buffer_size`，以适应系统内存和负载。
11. **优化存储引擎**：
    - 根据应用程序需求选择适当的存储引擎，如InnoDB或MyISAM，并配置存储引擎参数。
12. **减少不必要的连接**：
    - 使用连接池来管理数据库连接，并确保不会打开过多的连接。
13. **监控性能**：
    - 使用性能监控工具来跟踪数据库的性能，及时发现问题。
14. **数据备份和恢复**：
    - 定期备份MySQL和Redis的数据，以便在灾难恢复时使用。确保备份数据的安全存储，并测试备份恢复流程。
15. **安全漏洞修复**：
    - 定期更新MySQL和Redis的版本以修复已知的安全漏洞。保持软件更新，以减少潜在的攻击风险

## MySQL

# MySQL

## 基础

### SQL通用语法

1.SQL语句可以单行或多行书写，以分号结尾。

2.SQL语句可以使用空格/缩进来增强语句的可读性。

3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。

4.注释：

单行注释：-注释内容或#注释内容（MySQL特有）

多行注释：

```
/*注释内容*/
```

### SQL分类

| 分类 |            全称            |     说明     |
| :--: | :------------------------: | :----------: |
| DDL  |  Data Definition Language  | 数据定义语言 |
| DML  | Data Manipulation Language | 数据操作语言 |
| DQL  |    Data Query Language     | 数据查询语言 |
| DCL  |   Data Control Language    | 数据控制语言 |

### DDL

#### DDL-数据库-操作

##### 查询

查询所有数据库：

```mysql
SHOW DATABASES;
```

查询当前数据库：

```mysql
SELECT DATABASE();
```

##### 创建

```mysql
CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];
```

##### 删除

```mysql
DROP DATABASE [IF EXISTS]数据库名;
```

##### 使用

```mysql
USE 数据库名;
```

#### DDL-表操作-查询

##### 查询当前数据库所有表

```mysql
SHOW TABLES;
```

##### 查询表结构

```mysql
DESC 表名;
```

##### 查询指定表的建表语句

```mysql
SHOW CREATE TABLE 表名;
```

#### DDL-表操作-创建

```mysql
CREATE TABLE 表名(
    字段1 字段1类型[COMMENT 字段1注释]
    字段2 字段2类型[COMMENT 字段2注释]
    ...
    字段n 字段n类型[COMMENT 字段n注释]
)[COMMENT 表注释];
```

#### DDL数据类型及案例

时间类型

| 分类       | 类型       | 大小               | 描述                         |                                                       |
| ---------- | ---------- | ------------------ | ---------------------------- | ----------------------------------------------------- |
|            | CHAR       | 0-255 bytes        | 定长字符串（性能好）         | 性别 gender char(10)                                  |
|            | VARCHAR    | 0-65535 bytes      | 变长字符串（性能较差）       | 原因：需要根据内容去计算使用的空间 username (varchar) |
|            | TINYBLOB   | 0-255 bytes        | 不超过255个字符的二进制数据  |                                                       |
| 字符串类型 | TINYTEXT   | 0-255 bytes        | 短文本字符串                 |                                                       |
|            | BLOB       | 0-65535 bytes      | 二进制形式的长文本数据       |                                                       |
|            | TEXT       | 0-65535 bytes      | 长文本数据                   |                                                       |
|            | MEDIUMBLOB | 0-16777215 bytes   | 二进制形式的中等长度文本数据 |                                                       |
|            | MEDIUMBLOB | 0-16777215 bytes   | 中等长度文本数据             |                                                       |
|            | LONGBLOB   | 0-4294967295 bytes | 二进制形式的极大文本数据     |                                                       |
|            | LONGTEXT   | 0-4294967295 bytes | 极大文本数据                 |                                                       |

日期类型

| 分类     | 类型      | 大小 | 范围                                       | 形式                | 描述             |
| -------- | --------- | ---- | ------------------------------------------ | ------------------- | ---------------- |
|          | DATE      | 3    | 1000-01-01 至 9999-12-31                   | YYYY-MM-DD          | 日期值           |
|          | TIME      | 3    | -838:59:59 至 838:59:59                    | HH:MM:SS            | 时间值或持续时间 |
| 日期类型 | YEAR      | 1    | 1901至2155                                 | YYYY                | 年份值           |
|          | DATETIME  | 8    | 1000-01-01 00:00:00至 9999-12-31 23:59:59  | YYYY-MM-DD HH:MM:SS | 混合日期和时间值 |
|          | TIMESTAMP | 4    | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值 |

####  DDL-表操作-修改

##### 添加字段

```mysql
ALTER TABLE 表名 ADD 字段名 类型（长度） [COMMENT 注释][约束];
```

##### 修改数据类型

```mysql
ALTER TABLE 表名 MODIFY 字段名 新数据类型（长度）;
```

##### 修改字段名和字段类型

```mysql
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束]
```

##### 删除字段

```mysql
ALTER TABLE 表名 DROP 字段名;
```

##### 修改表名

```mysql
ALTER TABLE 表名 RENAME TO 新表名;
```

#### DDL-表操作-删除

##### 删除表

```mysql
DROP TABLE [IF EXISTS] 表名;
```

##### 删除指定表，并重新创建该表

```mysql
TRUNCATE TABLE 表名;
```

在删除表时，表中的全部数据也会被删除

### DML

增删改

添加数据(INSERT)

修改数据(UPDATE)

删除数据(DELETE)

#### DML-添加数据

给指定字段添加数据

```mysql
INSERT INTO 表名 (字段名1，字段名2,...) VALUES (值1，值2，...);
```

给全部字段添加数据

```mysql
INSERT INTO 表名 VALUES(值1,值2,...);
```

批量添加数据

```mysql
INSERT INTO 表名 (字段名1,字段名2,...) VALUES(值1，值2,...)，(值1,值2,...);
```

```mysql
INSERT INTO 表名 VALUES (值1，值2,...),(值1,值2,...);
```

**注意**

1.插入数据时，指定的字段顺序需要与值的顺序是一一对应的。

2.字符串和日期型数据应该包含在引号中。

3.插入的数据大小，应该在字段的规定范围内。

#### DML-修改数据

```mysql
UPDATE 表名 SET 字段名1=值1，字段名2=值2，...[WHERE 条件];
```

注意：修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表所有数据。

#### DML-删除数据

```mysql
DELETE FROM 表名 [WHERE 条件]
```

DELETE语句条件可有可无，若没有条件，则会删除整张表所有数据

DELETE语句不能删除某一个字段的值（可以使用UPDATE）

### DQL

```mysql
SELECT
字段列表
FROM                    基本查询
表名列表
WHERE                   条件查询(WHERE)
条件列表
GROUP BY                分组查询(GROUP BY) 聚合函数(max、min、count、avg、sum等)
分组字段列表
HAVING
分组后条件列表
ORDER BY                排序查询(ORDER BY)
排序字段列表
LIMIT                   分页查询(LIMIT)
分页参数
```

#### DQL-基本查询

##### 查询多个字段

```mysql
SELECT 字段1,字段2,字段3,... FROM 表名;
```

```mysql
SELECT * FROM 表名;
```

##### 设置别名

```mysql
SELECT 字段1 [AS 别名1]，字段2 [AS 别名2]... FROM 表名
```

##### 去除重复记录

```mysql
SELECT DISTINCT 字段列表 FROM 表名;
```

#### DQL-条件查询

##### 语法

```mysql
SELECT 字段列表 FROM 表名 WHERE 条件列表;
```

##### 条件

| 比较运算符         | 功能                                     |
| ------------------ | ---------------------------------------- |
| >                  |                                          |
| >=                 |                                          |
| <                  |                                          |
| <=                 |                                          |
| =                  |                                          |
| <>或!=             |                                          |
| BETWEEN ... AND... | 在某个范围内（含最小最大）               |
| IN(...)            | 在in之后的列表中的值，多选一             |
| LIKE占位符         | 模糊匹配(_匹配单个字符，%匹配任意个字符) |
| IS NULL            | 是NULL                                   |

| 逻辑运算符 | 功能     |
| ---------- | -------- |
| AND 或 &&  | 并且     |
| OR 或 \|\| | 或者     |
| NOT 或 !   | 非，不是 |

#### DQL-聚合函数

##### 介绍

将一列数据作为一个整体，进行纵向计算。

##### 常见聚合函数

| 函数  | 功能     |
| ----- | -------- |
| count | 统计数量 |
| max   | 最大值   |
| min   | 最小值   |
| avg   | 平均值   |
| sum   | 求和     |

##### 语法

```mysql
SELECT 聚合函数(字段列表) FROM 表名;
```

注意:null值不参与所有聚合函数运算。

#### DQL-分组查询

##### 语法

```mysql
SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名[HAVING 分组后过滤条件];
```

#####  where和having的区别

执行时机不同:where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤

判断条件不同:where不能对聚合函数进行判断，而having可以。

![image-20230802235604989](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230802235604989.png)

注意：

执行顺序:where>聚合函数>having

分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。

#### DQL-排序查询

##### 语法

```mysql
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2，排序方式2;
```

##### 排序方式

ASC：升序（默认值）

DESC：降序

注意：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。

#### DQL-分页查询

##### 语法

```mysql
SELECT 字段列表 FROM 表名 LIMIT 起始索引，查询记录数;
```

注意

1.起始索引从0开始，起始索引=（查询页码-1）*每页显示记录数

2.分页查询是数据库的方言，不同的数据库有不同的实现，Mysql中是LIMIT

3.如果查询的是第一页数据，起始索引可以省略，直接简写为limit10.

例子：

查询第一页

```mysql
select *from emp limit 0,10;
```

查询第二页

```mysql
select *from emp limit 10,10;
```

 

#### DQL-执行顺序

```mysql
SELECT                4   
字段列表
FROM                  1    基本查询
表名列表
WHERE                 2  条件查询(WHERE)
条件列表
GROUP BY              3  分组查询(GROUP BY) 聚合函数(max、min、count、avg、sum等)
分组字段列表
HAVING
分组后条件列表
ORDER BY               5 排序查询(ORDER BY)
排序字段列表
LIMIT                  6 分页查询(LIMIT)
分页参数
```

### DCL

主要管理数据库用户、控制数据库的访问权限。

#### DCL-用户管理

##### 查询用户

```mysql
USE mysql;
SELECT *FROM user;
```

##### 创建用户

```
CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
```

##### 修改用户密码

```
ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';
```

##### 删除用户

```
DROP USER '用户名'@'主机名'
```

这里一个例子值得记录

```mysql
#创建用户splash，可以在任意主机访问该数据库，密码为123456
create user 'splash'@'%' identified by '123456';
```

#### DCL-权限控制

|  权限  |        说明        |
| :----: | :----------------: |
|  ALL   |      所有权限      |
| SELECT |      查询数据      |
| INSERT |      插入数据      |
| UPDATE |      修改数据      |
| DELETE |      删除数据      |
| ALTER  |       修改表       |
|  DROP  | 删除数据库/表/视图 |
| CREATE |   创建数据库/表    |

##### 查询权限

```mysql
SHOW GRANTS FOR '用户名'@'主机名';
```

##### 授予权限

```mysql
GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';
```

##### 撤销权限

```mysql
REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';
```

### 函数

```mysql
SELECT 函数(参数);
```



#### 字符串函数

|           函数           |                           功能                            |
| :----------------------: | :-------------------------------------------------------: |
|   CONCAT(S1,S2,...Sn)    |         字符串拼接，将S1,S2,...Sn拼接成一个字符串         |
|        LOWER(str)        |                  将字符串str全部转为小写                  |
|        UPPER(str)        |                         转为大写                          |
|     LPAD(str,n,pad)      | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |
|     RPAD(str,n,pad)      | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 |
|        TRIM(str)         |                去掉字符串头部和尾部的空格                 |
| SUBSTRING(str,start,len) |      返回从字符串str从start位置起的len个长度的字符串      |

```mysql
select upper('Hello');
```

```mysql
update enp set workno = lpad(workno,5,'0');
```

### 约束

#### 概念

约束是作用于表中字段上的规则，用于限制存储在表中的数据。

#### 目的

保证数据库中数据的正确、有效性和完整性。

#### 分类

|   约束   |                          概述                          |   关键字    |
| :------: | :----------------------------------------------------: | :---------: |
| 非空约束 |               限制该字段的数据不能为null               |  NOT NULL   |
| 唯一约束 |          保证该字段的所有数据都是唯一，不重复          |   UNIQUE    |
| 主键约束 |        主键是一行数据的唯一标识，要求非空且唯一        | PRIMARY KEY |
| 默认约束 |     保存数据时，如果未指定该字段的值，则采用默认值     |   DEFAULT   |
| 检查约束 |                保证字段值满足某一个条件                |    CHECK    |
| 外键约束 | 用来两张表的数据之间建立连接，保证数据的一致性和完整性 | FOREIGN KEY |

#### 外键约束

##### 概念

外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。

![image-20230809203353244](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230809203353244.png)

没有建立外键关联，无法保证数据的一致性和完整性

##### 语法

添加外键

```mysql
CREATE TABLE 表名(
    字段名 数据类型
    ...
    [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)
);
```

```mysql
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);
```

删除外键

```mysql
ALTER TABLE 表名 ADD CONSTRAINT 外键名称
```

##### 删除/更新行为

|    行为     |                             说明                             |
| :---------: | :----------------------------------------------------------: |
|  NO ACTION  | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与RESTRICT一致) |
|  RESTRICT   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与NO ACTION一致) |
|   CASCADE   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。 |
|  SET NULL   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null |
| SET DEFAULT |  父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)  |

```mysql
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名) ON UPDATE CASCADE ON DELETE CASCADE;
```

### 多表关系

#### 概述

在项目开发中，在进行数据库表结构设计时，会根据业务需求和业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，分为三种：

1.一对多

2.多对多

3.一对一

#### 一对多

案例：部门与员工的关系

关系：一个部门对应多个员工，一个员工对应一个部门

实现：在多的一方建立外键，指向少的一方的主键

![image-20230809214916885](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230809214916885.png)

#### 多对多

案例：学生与课程的关系

关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择

实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键。

![image-20230809215951140](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230809215951140.png)

#### 一对一

案例：用户与用户详情的关系

关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中

实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）

![image-20230813161645215](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230813161645215.png)

### 多表查询概述

#### 概述

指从多张表中查询数据

```mysql
#多表查询  #笛卡尔积
select * from emp ,dept;
```

#### 笛卡尔积

笛卡尔乘积指数学中，两个集合A集合和B集合的所有组合情况**（在多表查询时，需要消除无效的笛卡尔积）**

![image-20230813162418896](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230813162418896.png)

消除笛卡尔积：

**WHERE**

![image-20230813162622002](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230813162622002.png)

### 多表查询分类

#### 连接查询

##### 内连接

相当于查询A、B交集部分数据

###### 内连接查询语法

隐式内连接

```mysql
SELECT 字段列表 FROM 表1，表2 WHERE 条件...;
```

显式内连接

```mysql
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件...;
```



##### 外连接

###### 左外连接

查询左表（表1）所有数据，以及两张表交集部分数据（可以省略outer）

```mysql
SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件...;
```

![image-20230813210426204](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230813210426204.png)

###### 右外连接

查询右表（表2）所有数据，以及两张表交集部分数据

```mysql
SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件...;
```



##### 自连接

当前表与自身的连接查询，自连接必须使用表别名

自连接查询语法：

```mysql
SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件...;
```

自连接查询，可以是内连接查询，也可以是外连接查询

#### 联合查询-union,union all

就是把多次查询的结果合并起来，形成一个新的查询结果集

```mysql
SELECT 字段列表 FROM 表A...;
UNION [ALL]  #去掉ALL的话是对结果去重
SELECT 字段列表 FROM 表B...;
##联合查询的列数和字段类型需要保持一致
```

对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。

union all会将全部的数据直接合并在一起

union会对合并之后的数据去重

### 子查询

#### 概念

SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。

```mysql
SELECT *FROM t1 WHERE column1 = (SELECT column1 FROM t2);
```

子查询外部的语句可以是INSERT/UPDATE/DELETE/SELECT中的任意一个

#### 子查询分类

根据子查询结果不同，分为：

1.标量子查询（子查询结果为单个值）

2.列子查询（子查询结果为一列）

3.行子查询（子查询结果为一行）

4.表子查询（子查询结果为多行多列）

#### 标量子查询

标量子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式。

常用的操作符：= <> > >= < <=

![image-20230813232735951](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230813232735951.png)

#### 列子查询

子查询返回的结果是一列（可以是多行），这种子查询称为列子查询

常用的操作符：IN、NOT IN、ANY、SOME、ALL

| 操作符 |                  描述                  |
| :----: | :------------------------------------: |
|   IN   |      在指定的集合范围之内，多选一      |
| NOT IN |         不在指定的集合范围之内         |
|  ANY   |  子查询返回列表中，有任意一个满足即可  |
|  SOME  | 与ANY等同，使用SOME的地方都可以使用ANY |
|  ALL   |    子查询返回列表的所有值都必须满足    |

![image-20230813233312189](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230813233312189.png)

#### 行子查询

子查询返回的结果是一行（可以是多列）

常用的操作符：=、<>、IN、NOT IN

![image-20230814140214421](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230814140214421.png)

### 事务

#### 简介

事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求

即这些操作要么同时成功，要么同时失败

![image-20230816112318106](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230816112318106.png)

默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务

#### 操作

##### 查看/设置事务提交方式

```mysql
SELECT @@autocommit;
SET @@autocommit=0;
```

##### 提交事务

```mysql
COMMIT;
```

##### 回滚事务

```mysql
ROLLBACK;
```

##### 开启事务

```mysql
START TRANSACTION 或 BEGIN
```

##### 提交事务

```mysql
COMMIT;
```

回滚事务

```mysql
ROLLBACK;
```

#### 事务四大特性-ACID

原子性(Atomicity):事务是不可分割的最小操作单元，要么全部成功，要么全部失败

一致性(Consistency):事务完成时，必须使所有的数据都保持一致状态

隔离性(Isolation):数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行

持久性(Durability):事务一旦提交或回滚，它对数据库中的数据的改变是永久的

#### 并发事务问题

|    问题    |                             描述                             |
| :--------: | :----------------------------------------------------------: |
|    脏读    |          一个事务读取到另外一个事务还没有提交的数据          |
| 不可重复读 |       一个事务先后读取同一条记录，但两次读取的数据不同       |
|    幻读    | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，像出现了"幻影" |

![image-20230816120944913](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230816120944913.png)

![image-20230818153856646](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230818153856646.png)

![image-20230818154303765](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230818154303765.png)

#### 事务隔离级别

|       隔离级别        | 脏读 | 不可重复读 | 幻读 |
| :-------------------: | :--: | :--------: | :--: |
|    Read uncommited    |  1   |     1      |  1   |
|     Read commited     |  0   |     1      |  1   |
| Repeatable Read(默认) |  0   |     0      |  1   |
| Serializable(串行化)  |  0   |     0      |  0   |

```mysql
##查看事务隔离级别
SELECT @@TRANSACTION_ISOLATION;

##设置事务隔离级别
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL[READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE]
```

## 进阶

### 存储引擎

#### MySQL体系结构

![image-20230818235159487](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230818235159487.png)

连接层：

最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的权限。

服务层：

第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有存储引擎的功能也在这一层实现，如过程、函数等。

引擎层：

存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同存储引擎具有不同的功能。这样我们可以根据自己的需要，来选取合适的存储引擎。

存储层：

主要是将数据存储在文件系统之上，并完成与存储引擎的交互。

#### 存储引擎简介

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式

存储引擎是基于表的，而非库，所以存储引擎也被称为表类型

在创建表时，指定存储引擎

```mysql
CREATE TABLE 表名(
    字段1 字段1类型[COMMENT 字段1注释],
    ...
    字段n 字段n类型[COMMENT 字段n注释]
)ENGINE = INNODB [COMMENT 表注释];
```

查看当前数据库支持的存储引擎

```mysql
SHOW ENGINES;
```

#### 存储引擎特点

##### InnoDB

InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的mysql存储引擎

**特点**

1.DML操作遵循ACID模型，支持**事务**

2.**行级锁**，提高并发访问性能

3.支持**外键**FOREIGN KEY约束，保证数据的完整性和正确性

**文件**

xxx.ibd:xxx表示表名，InnoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构(frm、sdi)、数据和索引。

参数:innodb_file_per_table

```mysql
show variables like 'innodb_file_per_table'
```

逻辑存储结构

![image-20230819231209204](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230819231209204.png)

##### MyISAM

**介绍**

MySQL早期的默认存储引擎

**特点**

不支持事务，不支持外键

支持表锁，不支持行锁

访问速度快

**文件**

xxx.sdi:存储表结构信息

xxx.MYD:存储数据

xxx.MYI:存储索引

##### Memory

**介绍**

Memory引擎的表数据存储在内存中，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存值

**特点**

内存存放

hash索引(默认)

**文件**

xxx.sdi:存储表结构信息

![image-20230819231855403](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230819231855403.png)

![image-20230819234325678](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230819234325678.png)

MyISAM(已经有NoSQL代替)

MEMORY(已经有redis代替)

### 索引

#### 介绍

索引(index)是帮助Mysql高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这张数据结构就是索引。

![image-20230820150858849](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230820150858849.png)

|                            优势                             |                             劣势                             |
| :---------------------------------------------------------: | :----------------------------------------------------------: |
|           提高数据检索的效率，降低数据库的IO成本            |                    索引列也是要占用空间的                    |
| 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 | 索引大大提高了查询效率，但同时也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率更低 |

#### 索引结构

![image-20230820151323310](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230820151323310.png)

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构：

|      索引结构       |                             描述                             |
| :-----------------: | :----------------------------------------------------------: |
|     B+Tree索引      |          最常见的索引类型，大部分引擎都支持B+树索引          |
|      Hash索引       | 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 |
|  R-tree(空间索引)   | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型 |
| Full-text(全文索引) |          是一种通过建立倒排索引，快速匹配文档的方式          |

![image-20230820151726882](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230820151726882.png)

#### 分类

|   分类   |                         含义                         |           特点           |  关键字  |
| :------: | :--------------------------------------------------: | :----------------------: | :------: |
| 主键索引 |                针对表中主键创建的索引                | 默认自动创建，只能有一个 | PRIMARY  |
| 唯一索引 |           避免同一个表中某数据列中的值重复           |        可以有多个        |  UNIQUE  |
| 常规索引 |                   快速定位特定数据                   |        可以有多个        |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 |        可以有多个        | FULLTEXT |

在InnoDB存储引擎里，根据索引的存储方式，又可以分为以下两种：

|           分类            |                            含义                            |         特点         |
| :-----------------------: | :--------------------------------------------------------: | :------------------: |
| 聚集索引(Clustered Index) | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个 |
| 二级索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 |     可以存在多个     |

聚集索引选取规则：

1.如果存在主键，主键索引就是聚集索引

2.如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引

3.如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引

#### 语法

创建索引

```mysql
CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name(index_col_name,...);
```

查看索引

```mysql
SHOW INDEX FROM table_name;
```

删除索引

```mysql
DROP INDEX index_name ON table_name;
```

#### SQL性能分析

##### SQL执行频率

MySQL客户端连接成功后，通过show [session|global] status命令可以提供服务器状态信息。

通过如下指令，可以查看当前数据库INSERT、UPDATE、DELETE、SELECT访问频次：

```mysql
SHOW GLOBAL STATUS LIKE 'Com______' #一个下划线等于一个字符一般七个
```

##### 慢查询日志

慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10秒)的所有SQL语句的日志。

查看慢查询开关

```mysql
show variables like 'slow_query_log';
```

MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件(/etc/my.cnf)中配置如下信息：

```
#开启MySQL慢日志查询开关
slow_query_log = 1
#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time = 2
```

查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log

修改完后然后重启

```shell
systemctl restart mysqld
```

##### profile详情

show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。

通过have_profiling参数，能够看到当前MySQL是否支持profile操作：

```mysql
SELECT @@have_profiling;
```

默认profiling是关闭的，可以通过set语句在session/global级别开启profiling:

```mysql
SET profiling = 1;
```

执行一系列的业务SQL的操作，然后通过以下指令查看指令的执行耗时

```mysql
##查看每一条SQL的耗时基本情况
show profiles;

##查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;

##查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```

##### *explain执行计划

EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序

###### 语法

```mysql
##直接在select 语句之前加上关键字explain/desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```

![image-20230820233646330](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230820233646330.png)

EXPLAIN执行计划各字段含义：

id：select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下;id不同值越大越先执行)

select_type：表示SELECT类型，常见取值有SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等

type：表示连接类型，性能由好到差的连接类型为NULL、system、const(主键、唯一索引）、eq_ref、ref（非唯一性索引）、range、index、all

possible_key:显示可能应用在这张表上的索引，一个或多个

key：实际使用的索引，如果为NULL，则没有使用索引

Key_len:表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好

rows：MySQL认为必须要执行查询的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确

filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好

#### 使用规则

##### 验证索引效率

在未建立索引之前，执行如下SQL语句，查看SQL耗时

```mysql
SELECT *FROM tb_sku WHERE sn = '1000000003145001';
```

针对字段创建索引

```mysql
create index idx_sku_sn on tb_sku(sn);
```

然后再次执行相同的SQL语句，再次查看SQL的耗时

```mysql
SELECT * FROM tb_sku WHERE sn = '1000000003145001';
```

##### 最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则

最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列

如果跳过某一列，索引将部分失效（后面的字段索引失效）

##### 范围查询

联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。（尽量使用例如>=这种运算符

##### 索引列运算

不要在索引列上进行运算操作，索引将失效

##### 模糊查询

如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效

##### or连接的条件

用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到

##### 数据分布影响

如果MySQL评估使用索引比全表更慢，则不会使用索引

##### SQL提示

是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的

use index:

```mysql
explain select * from tb_user use index(idx_user_pro) where profession = '软件工程';
```

ignore index:

```mysql
explain select * from tb_user ignore index(idx_user_pro) where profession = '软件工程';
```

force index:

```mysql
explain select * from tb_user force index(idx_user_pro) where profession = '软件工程';
```

##### 覆盖索引

尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少使用select *

![image-20230821113039567](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230821113039567.png)

using index condition：查找使用了索引，但是需要回表查询数据

using where;using index：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据

![image-20230821113835945](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230821113835945.png)

最优方案：为username,password建立联合索引

##### 前缀索引

当字段类型为字符串(varchar,text等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

语法

```mysql
create index idx_xxxx on table_name(column(n));
```

前缀长度

可以根据索引的选择性来决定，选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高查询效率越高

### SQL优化 

##### insert优化

###### 批量插入

```mysql
insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'jerry');
```

###### 手动提交事务

```mysql
begin;
insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'jerry');
insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'jerry');
insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'jerry');
commit;
```

###### 主键顺序插入

```mysql
主键乱序插入： 8 1 9 21 88
主键顺序插入： 1 2 3 4 5
```

###### 大批量插入数据-load

如果一次需要插入大批量数据，使用insert语句插入性能较低，此时可以使用load

```mysql
##客户端连接服务端时，加上参数--local-infile
mysql --local-infile -u root -p
##设置全局参数local_infile为1，开启从本地加载文件导入数据开关
set global local_infile = 1
##执行load指令将准备好的数据，加载到表机构中
load data local infile "/root/sql1.log" into table 'tb_user' fields terminated by ',' lines terminated by '\n';
```

##### 主键优化

尽量使用主键顺序插入

主键设计原则：

1.满足业务需求的情况下，尽量降低主键的长度。

2.插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键

3.尽量不要使用UUID做主键或者是其他自然主键，如身份证号。

4.业务操作时，避免对主键的修改。

##### order by优化

```mysql
#根据age,phone进行降序一个升序一个降序
explain select id,age,phone from tb_user order by age asc,phone desc;
#创建索引
create index idx_user_age_phone_ad on tb_user(age asc,phone desc);
#根据age,phone进行降序一个升序一个降序
explain select id,age,phone from tb_user order by age asc,phone desc;
```

##### group by优化

在分组操作时，可以通过索引来提高效率

分组操作时，索引的使用也是满足最左前缀法则的。

##### limit优化

优化思路：

一般分页查询时，通过创建覆盖索引能够比较好的提高性能，可以通过覆盖索引加子查询形式进行优化

```mysql
explain select * from tb_sku t ,(select id from tb_sku order by id limit 20000,10) a where t.id = a.id;
```

##### update优化

```mysql
update student set no = '2000100100' where id = 1;
```

```mysql
update student set no = '2000100105' where name = '韦一笑';
```

#### SQL优化总结

![image-20230821131718380](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230821131718380.png)

## GO

# Golang个人总结

##                          SplashNirvana2K

### https://github.com/Pumnn1ayLee/Go_Note

## 写在前面

每种语言都有每种语言的独特的应用领域。



例如

嵌入式领域-----C和汇编是首选

操作系统领域-----C是首选

系统级服务编程领域-----C++是首选

企业级应用程序和Web应用领域-----Java是首选



而Go产生主要有以下原因：

1.当前编程语言对并发的支持不是很好，不能很好的发挥多核CPU的能力。

2.程序规模越来越大，编译速度越来越慢。

3.某些特性的实现不怎么优雅，程序员花费更多的精力来应对语法而不是问题域。



**Go语言就是为了解决并发支持不友好、编译速度慢、编译复杂的。**



本个人总结将以最简单直接的方式记录个人对golang的学习。



以下表格选自书《Go语言核心编程》：

|    特性集合    |      特性项      |                 Go                 |           C            |              Java               |
| :------------: | :--------------: | :--------------------------------: | :--------------------: | :-----------------------------: |
|    基础语法    |  关键字和保留字  |                25个                |        ANSI32个        |            大于48个             |
|                |     控制结构     |        支持顺序、循环、分支        |  支持顺序、循环、分支  |      支持顺序、循环、分支       |
|    类型系统    |    动、静特性    |    静态语言、支持运行时动态类型    |        静态语言        |            静态语言             |
|                |    强、弱特性    |               强类型               |         弱类型         |             强类型              |
|                |   隐式类型推导   |                支持                |           否           |               否                |
|                |     类型安全     |              类型安全              |       非类型安全       |            类型安全             |
|                |  自定义数据类型  |           支持type自定义           |         struct         | 通过类/接口实现自定义类型和行为 |
|      抽象      |       函数       |                支持                |          支持          |              支持               |
|                |   面向对象支持   |        类型组合支持面向对象        | struct内嵌函数指针支持 |             类/接口             |
|                |       接口       |              Duck类型              |     void*间接支持      |            显式声明             |
|                |       多态       |            通过接口支持            |     void*间接支持      |       接口及继承关系支持        |
|     元编程     |     泛型支持     |                 有                 |           无           |               有                |
|                |     反射支持     |                 有                 |           无           |               有                |
| 平台和运行模式 |     编译模式     |          编译成可执行文件          |    编译成可执行文件    |        编译成中间字节码         |
|                |     运行模式     |              直接运行              |        直接运行        |         虚拟机加载运行          |
|                |     内存管理     |          支持自动垃圾回收          |        手动管理        |        支持自动垃圾回收         |
|                |     并发支持     |        协程（语言原生支持）        |  OS线程（库支持协程）  | Java线程（JVM内部映射到OS线程） |
|                |     交叉编译     |                支持                |          支持          |     中间代码无交叉编译必要      |
|                |      跨平台      |                支持                |          支持          |           原生跨平台            |
|   语言软实力   | 标准库和第三方库 |           丰富、发展很快           |         很丰富         |             很丰富              |
|                |       框架       |           丰富、发展很快           |         很丰富         |             很丰富              |
|                |    语法兼容性    |            向前兼容性好            |      向前兼容性好      |          向前兼容性好           |
|                |      影响力      |          社区活跃，Google          |     40多年宝刀未来     |  社区活跃、近几年受Oracle控制   |
|                |     应用领域     | 云计算基础设施软件、中间件、区块链 |      OS及系统软件      |   企业级应用、大数据、移动端    |



**当然，学习笔记怎么可能完全是课本照搬呢？！**

<font size = 16>精简易懂</font>才是重点

### 基础

### 标识符

#### 关键字

Go有**25个关键字**



**引导程序整体结构**的有**8个**关键字：

package  //定义包名

import  //导入包名

const  //常量声明

var  //变量声明

func  //函数定义

defer  //延迟调用

go  //并发语法

return  //函数返回



**声明复合数据结构**的有**4个**关键字：

struct  //定义结构类型

interface  //定义接口

map  //声明或创建map类型

chan  //声明或创建通道类型



**控制程序结构**的有**13个**关键字：

if else  //if else语句

for range break continue  //for循环使用

switch select type case default fallthrough  //switch和select语句

goto  //goto语句跳转



数据类型标识符

数值（16个）

  整型（12个）：byte int int8 int16 int32 int64

​                             uint uint8 uint 16 uint32 uint64 uintprt

  浮点型（2个）： float32 float64

  复数型（2个）： complex64 complex128



字符和字符串型（2个）

string rune



接口型（1个）

error



布尔型（1个）

bool



#### 内置函数标识符

make

new

len

cap

append

copy

delete

panic

recover

close

complex

real

image

Print

Println



#### 常量值标识符



true false

iota

nil



#### 空白标识符

_

### 变量和常量

变量指向的内存可以被修改，常量指向的内存不能被修改。

#### 变量

##### 变量的显式声明

```go
var a int = 1
var a int = 2*3
var a int = b
```

##### 短类型声明

```go
varName := value
```

:= 声明只能出现在函数内

此时Go编译器自动进行数据类型判断

Go支持多个类型变量同时声明并赋值，如：

```go
a,b := 1,"hello"
```

1.变量实际指向地址里存放的值

2.Go语言提供自动内存管理，编译器使用栈逃逸技术能够自动为变量分配空间，可能在栈上也可能在堆上。

3.类型决定了该变量存储的值怎么解析，以及支持哪些操作和运算。

4.Go内部使用统一的命名空间对变量进行管理，每个变量都有一个唯一的名字。

#### 常量

常量使用一个名称来绑定一块内存地址，该内存地址存放的数据类型由定义常量时的类型决定，并且该内存地址里面存放的内容不可以改变。

```go
const (
c0 = iota //c0 == 0
c1 = iota //c1 == 1
c2 = iota //c2 == 2
)

//简写模式
const(
c0 = iota // c0 ==0
c1
c2
)

//分开的const语句,iota每次都从0开始
const x = iota  // x == 0
const y = iota  // y == 0
```

### 字符串

```go
var a = "hello,world"
```

1.字符串是常量，可以通过类似数组的索引访问其字节单元，但不能修改某个值。

```go
var a = "hello world"
b := a[0]
a[1] = 'a' //error
```

2.字符串转换为切片[]byte(s)要慎用，尤其是数据量大的时候（每转换一次都要转换内容）

```go
a := "hello world"
b := []byte(a)
```

3.字符串尾部不包含NULL字符

4.字符串类型底层实现是一个二元的数据结构，一个指向字节数组的起点，另一个是长度

```go
// runtime/string.go

type stringStruct struct{
str unsafe.Pointer  //指向底层字节数组的指针
len int  //字节数组长度
}
```

5.基于字符串创建的切片和原字符串指向相同的底层字符数组，一样不能修改，对于字符串的切片操作返回的字串仍然是string，而非slice,如：

```go
a := "hello world"
b := a[0:4]
c := a[1:]
d := a[:4]
```

6.字符串和切片的转换，字符串可以转换为字节数组，也可以转换为Unicode的字数组：

```go
a := "hello，世界"
b := []byte(a)
c := []rune(a)
```

### rune类型

rune表示Unicode编码的字符，在Go内部是int32类型的别名，占用4个字节。

Go语言默认的字符编码是UTF-8类型。

### 指针

1.在赋值语句中，*T出现在“=”左边表示指针声明，*T出现在在“=”右边表示取指针指向的值。

```go
var a = 11
p := &a //*p和a的值都为11
```

2.结构体指针访问结构体字段仍然使用"."点操作符

```go
type User struct{
name string
age int
}
andes := User{
name : "andes",
age : 18,
}
p := &andes
fmt.Println(p.name)
```

3.Go不支持指针运算。

Go由于支持垃圾回收，如果支持指针运算，则会给垃圾回收带来很多不便（点名C和C++)。

```go
a := 1234
p := &a
p++ //不允许
```

4.函数中允许返回局部变量的地址。

Go编译器使用“栈逃逸”机制将这种局部变量的空间分配在堆上

```go
func sum(a,b int) *int{
sum := a+b
return &sum  //允许，sum会分配在堆heap上
}
```

### 数组

数组的类型名是[n]elementType，其中n是数组长度，elementType是数组元素类型。

不是引用类型！

#### **数组的初始化**

```go
a := [3]int{1,2,3} //指定长度和初始化字面量
```

```go
a := [...]int{1,2,3} //不指定长度，但是由后面的初始化列表数量来确定其长度
```

```go
a := [3]int{1:1,2:3} //指定总长度，并通过索引值进行初始化，没有初始化元素时使用类型默认值
```

```go
a := [...]int{1:1,2:3} //不指定总长度，，并通过索引值进行初始化，没有初始化元素时使用类型默认值
```

##### 数组的特点

1.创建完长度后就固定，不可以再追加元素

2.数值为值类型，数组赋值或作为函数参数都是值拷贝

3.[10]int和[20]int表示不同的类型

4.可以根据数组创建切片

### 切片

一种变长数组

数据结构中有指向数组的指针

是一种引用类型

Slice依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以实现自动重分配并生成新的Slice。

#### Slice的数据结构

```go
type slice struct{
  array unsafe.Pointer //指针指向底层数组
  len int  //切片长度
  cap int  //底层数组容量
}
```

#### 切片的创建

##### 使用make创建Slice

```go
slice := make([]int,5,10)
```

![2d753d620467ea531ba7f769a948b95](C:\Users\97434\AppData\Local\Temp\WeChat Files\2d753d620467ea531ba7f769a948b95.png)

该Slice长度为5，即可以使用下标slice[0] ~ slice[4]来操作里面的元素，capacity为10，表示后续向 slice添加新的元素时可以不必重新分配内存，直接使用预留内存即可。

##### 使用数组创建Slice

```go
slice := array[5:7]
```

使用数组来创建Slice时，Slice将与原数组共用一部分内存

![image-20230705002305381](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230705002305381.png)

切片从数组array[5]开始，到数组array[7]结束（不含array[7]），即切片长度为2，数组后面的内容都作为切 片的预留内存，即capacity为5

数组和切片操作可能作用于同一块内存

#### Slice扩容

使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容

扩容实际上重新分配一块更大的内 存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去。

例如，当向一个capacity为5，且length也为5的Slice再次追加1个元素时，就会发生扩容，如下图所示：

![image-20230705002658257](C:\Users\97434\AppData\Roaming\Typora\typora-user-images\image-20230705002658257.png)

扩容操作只关心容量，会把原Slice数据拷贝到新Slice，追加数据由append在扩容结束后完成

上图可见，扩容后 新的Slice长度仍然是5，但容量由5提升到了10，原Slice的数据也都拷贝到了新Slice指向的数组中

**扩容容量选择遵循以下规则：**

1.如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；

2.如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；

使用append()向Slice添加一个元素的实现步骤如下： 

1. 假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice 
2. 原Slice容量不够，则将Slice先扩容，扩容后得到新Slice 
3. 将新元素追加进新Slice，Slice.len++，返回新的Slice

#### 切片支持的操作

len()返回切片长度

cap()返回切片底层数组容量

append()对切片追加元素

copy()用于复制一个切片

#### 字符串和切片的相关转换

```go
str := "hello，世界!"
a := []byte(str) //将字符串转换为[]byte类型切片
b := []rune(st) //将字符串转换为[]rune类型切片
```

#### 切片的底层结构

在Go语言中，切片（slice）是一种动态数组的数据结构，它提供了一种方便的方式来操作和管理变长的序列数据。切片的底层结构由三部分组成：指向底层数组的指针、切片的长度和切片的容量。

切片的底层结构可以表示为以下形式：

```go
type Slice struct {
    ptr      *ElementType // 指向底层数组的指针
    len      int          // 切片的长度
    cap      int          // 切片的容量
}
```

其中，`ElementType`是切片元素的类型。

切片的三个主要部分解释如下：

1. 指向底层数组的指针（ptr）： 切片实际上并不存储数据，它只是底层数组的一个视图。这个指针指向了底层数组的第一个元素。通过这个指针，切片可以访问底层数组中的数据。
2. 切片的长度（len）： 切片的长度表示当前切片中包含的元素个数。它可以通过内置的`len()`函数来获取。切片的长度不能超过切片的容量。
3. 切片的容量（cap）： 切片的容量表示底层数组中从切片的起始位置到底层数组末尾的元素个数。容量可以通过内置的`cap()`函数来获取。切片的容量决定了切片可以扩展的最大长度。

### map字典

#### map的创建

引用类型！

##### 字面量创建

```go
ma := map[string]int{"a" : 1,"b" : 2}
fmt.Println(ma["a"])
fmt.Println(ma["b"])
```

##### make函数创建

```go
ma := make(map[string]int,len) //map容量使用给定的len值
```

#### map支持的操作

访问格式：mapName[key]

可以使用range遍历一个map类型变量，但不保证每次迭代元素的顺序

删除map中某个键值：delete(mapName,key)

可以使用len()函数返回map中的键值对数量

```go
ma := make(map[int]string)
ma[1] = "tom"
ma[1] = "pony"
ma[2] = "jaky"
ma[3] = "andes"
delete(ma,3)

fmt.Println(len(ma))
for key,value := range ma{
fmt.Println("key is:",key,"value is:",value)
}
```

#### map的数据结构

Go 语言中的 `map` 数据结构是一个哈希表（hash table），用于存储键值对，并提供快速的插入、查找和删除操作。`map` 的底层实现通过哈希表来实现，每个哈希表由多个桶（buckets）组成，每个桶可以存储一个或多个键值对。每个桶内部使用链表或红黑树等数据结构来处理哈希冲突（多个键映射到同一个桶的情况）。

```go
+--------------------------------------------------+
|                    Hash Table                    |
+--------------------------------------------------+
|    Bucket 0    |    Bucket 1    |    Bucket 2    |
| +------------+ | +------------+ | +------------+ |
| | Key-Value  | | | Key-Value  | | | Key-Value  | |
| | Pairs      | | | Pairs      | | | Pairs      | |
| +------------+ | +------------+ | +------------+ |
|       ...      |       ...      |       ...      |
+--------------------------------------------------+

```

#### map如何实现扩容

当 `map` 中的键值对数量达到一定阈值时，为了保持查询效率，`map` 会自动进行扩容。扩容的过程涉及以下步骤：

1. 创建一个新的更大的哈希表。
2. 将原有哈希表中的键值对逐个重新哈希并插入新的哈希表中。
3. 一旦所有键值对都被重新插入，新的哈希表会取代旧的哈希表成为 `map` 的底层存储结构。

#### map是如何解决并发安全

在 Go 语言中，`map` 并不是并发安全的数据结构，这意味着在多个 goroutine 并发读写同一个 `map` 的情况下，可能会出现竞态条件（race condition）和数据不一致的问题。由于 `map` 不具备内置的并发安全性，如果在并发环境中需要使用 `map`，你需要采取额外的措施来保证并发安全性。

有几种常见的方式可以确保 `map` 的并发安全性：

1. **使用互斥锁（Mutex）：** 你可以使用互斥锁来保护对 `map` 的并发访问。在读写 `map` 之前，首先获取锁，然后执行操作，最后释放锁。这会确保同一时间只有一个 goroutine 可以访问 `map`。
2. **使用读写锁（RWMutex）：** 读写锁允许多个 goroutine 并发读取 `map`，但只允许一个 goroutine 进行写操作。这种方式在读多写少的场景下可以提高并发性能。
3. **使用并发安全的数据结构：** 如果你需要在并发环境中频繁使用键值存储，可以考虑使用专门设计的并发安全数据结构，例如 sync.Map。`sync.Map` 是 Go 标准库中提供的并发安全的键值存储，适用于高并发的情况。

#### sync.map适用于哪些场景

在使用 `sync.Map` 时，以下是一些适合的场景：

1. **读多写少的场景**：`sync.Map` 的性能优势在于它可以在多个协程之间共享数据，而无需显式的锁。在读多写少的情况下，性能可能会比传统的互斥锁（`sync.Mutex`）更好。
2. **临时数据缓存**：如果你需要在多个协程之间存储临时数据的缓存，并且这些数据的生命周期比较短暂，`sync.Map` 可以是一个不错的选择，因为它不需要手动的加锁和解锁。
3. **不需要强一致性的场景**：`sync.Map` 并不提供像传统的显式锁一样的强一致性保证。如果你的应用需要强一致性保证，那么你可能需要考虑使用传统的互斥锁或其他并发原语。
4. **复杂的并发数据访问模式**：如果你的应用中涉及复杂的数据访问模式，而且你想避免手动管理锁，`sync.Map` 可以简化代码并降低错误的风险。

#### 注意

1.Go内置的map不是并发安全的，并发安全的map可以使用标准包sync中的map

2.不要直接修改map value内某个元素的值，如果想修改map的某个键值，则必须整体赋值。

```go
type User struct{
    name string
    age int
}
ma := make(map[int]User)
andes := User{
    name : "andes",
    age : 18,
}

ma[1] = andes
//ma[1].age = 19 //error,不能通过map引用直接修改
andes.age = 19

ma[1] = andes //必须整体替换value
fmt.Printf("%v\n",ma)
```

### 结构Struct

1.struct结构中的类型可以是任意类型

2.struct的存储空间是连续的

struct有两种形式：1.struct类型字面量 2.使用type声明的自定义struct类型

#### struct类型字面量

格式：

```go
struct {
    FeildName FeildType
    FeildName FeildType
    FeildName FeildType
}
```

#### 自定义struct类型*

一般用这个

```go
type TypeName struct{
    FeildName FeildType
    FeildName FeildType
    FeildName FeildType
}
```

#### struct类型变量的初始化

```go
type Person struct{
    Name string
    Age int
}
type Student struct{
    *Person
    Number int
}

//推荐使用这种使用Feild名字的初始化方式
p := &Person{
    Name : "tata",
    Age : 12,
}

s := Student{
    Person : p,
    Number : 120,
}
```

### 控制结构

#### if else语句

```go
if x := f(); x < y{ //初始化语句中的声明变量x
    return x
} else if x > z{  //x在else if 里面一样可以被访问
    return z
} else {
    return y
}
```

#### 推荐

```go
err , file := os.Open("xxxx")
if err != nil{
    return nil,err
}
defer file.Close()
```

#### switch语句

1.switch后面可带一个可选的简单的初始化语句

2.switch后面的表达式是可选的，若没有表达式，则case是一个布尔表达式

3.switch支持相等比较运算的类型变量。

4.通过fallthough语句来强制执行case子句（不再判断下一个case子句的条件是否满足

5.支持default

6.switch和.(type)结合可以进行类型的查询

### 循环结构

#### for语句

```go
for init; condition;post{}
```

```go
for condition{}
```

```go
for {}
```

对数组、切片、字符串、map和通道的访问

```go
//访问map
for key,value := range map{}
for key := range map{}
```

```go
//访问数组
for index, value := range arry{}
for index := range arry{}
for _,value := range arry{}
```

```go
//访问切片
for index,value := range slice{}
for index := range slice{}
for _,value := range slice{}
```

```go
//访问通道
for value := range channel{}
```

## 函数

### 函数定义

```go
func funcName(param-list)(result-list){
    function-body
}
```

### 函数特点

1.函数可以没有输入参数，也可以没有返回值

```go
func A(){
    //do something
}
func A()int{
    return 1
}
```

2.多个相邻的相同类型参数可以使用简写模式

```go
func add(a,b int)int{
return a + b
}
```

3.支持有名的返回值

```go
func add(a,b int)(sum int){
sum = a + b
return // return sum 的简写模式
    // sum := a + b
    // return sum  需要显式调用return sum
}
```

4.不支持默认值参数

5.不支持函数重载

6.不支持命名函数的嵌套定义，支持嵌套匿名函数

```go
func add(a,b int)(sum int){
    a := func(x,y int) int {
        return x + y
    }
    return a(a,b)
}
```

### 多值返回

```go
func swap(a,b int)(int,int){
    return b,a
}
```

.如果多值返回值有错误类型，则一般将错误类型err作为最后一个返回值。

### 实参到形参的传递

Go函数实参到形参的传递永远是值拷贝，有时函数调用后实参指向的值发生了变化。那是因为参数传递的是指针值的拷贝。

```go
package main

import "fmt"

func chvalue(a int) int {
    a = a + 1
    return a
}

func chpointer(a *int){
    *a = *a + 1
    return
}

func main(){
    a := 10
    chvalue(a) //实参传递给形参是值传递
    fmt.Println(a)
    
    chpointer(&a) //仍然是值拷贝，只不过复制的是a的地址值
    fmt.Println(a)
}
```

### 不定参数

Go函数支持不定数目的形式参数。

使用param ...type的语法格式。

1.所有的不定参数类型必须是相同的

2.不定参数必须是函数的最后一个参数

3.不定参数名在函数体内相当于切片，切片操作同样适应不定参数

```go
for sum(arr ...int)(sum int){
    for _,v := range arr{
        sum += v
    }
    return
}
```

4.切片可以作为参数传递给不定参数，切片名后要加上"..."

```go
func sum(arr ...int)(sum int){
    for _,v := range arr{
        sum += v
    }
    return
}
func main(){
    slice := []int{1,2,3,4}
    array := [...]int{1,2,3,4}
    sum(slice...)
}
```

5.形参为不定参数的函数和形参为切片的函数类型不相同

```go
func suma(arr ...int)(sum int){
    for v := range arr{
        sum += v
    }
    return
}

for sumb(arr []int)(sum int){
    for v := range arr{
        sum += v
    }
    return
}

//类型不一样
fmt.Printf("%T\n",suma) //func(...int) int
fmt.Printf("%T\n",sumb) //func([]int) int
```

### 有名函数

有名函数可以直接调用和直接赋值给变量

```go
package main

func sum(a,b int) int {
    return a + b
}

func main(){
    sum(3,4) //直接调用
    f := sum //直接赋值给变量
    f(1,2)
}
```

### 匿名函数

匿名函数可以看作函数字面量

可以直接赋值给函数变量

可以当作实参

可以作为返回值

也可以直接被调用

```go
package main

import "fmt"

//直接赋值函数变量
var sum = func(a,b int)int {
    return a + b
}

func doinput(f func(int,int) ,a,b int)int{
    return f(a,b)
}

//作为返回值
func wrap(op string) func (int,int) int{
    switch op{
        case "add":
        return func(a,b int) int{
            return a + b
        }
    case "sub" :
        return func(a , b int) int{
            return a + b
        }
        default:
        return nil
    }
}

func main(){
    //匿名函数直接被调用
    defer func{
        if err := recover() ; err != nil{
            fmt.Println(err)
        }
    }()
    
    sum(1,2)
    
    //匿名函数作实参
    doinput(func(x,y int)int{
        return x + y
    }1,2)
    
    opFunc := wrap("add")
    re := opFunc(2,3)
    
    fmt.Printf("%d\n",re)
}
```

### defer

延迟调用，可以注册多个延迟调用，这些调用以先进后厨的顺序在函数返回前被执行。

defer后面必须是函数或方法的调用

defer函数的实参在注册时通过值拷贝传递进去

defer必须先注册后才能执行

当主动调用os.Exit(int)退出进程时，defer将不再被执行



如果defer位置不当，可能导致panic

defer会推迟资源的释放，尽量不要放到循环语句里面

defer中最好不要对有名返回值参数进行操作



### 闭包

闭包是由函数及其相关引用环境组合而成的实体，一般通过在匿名函数中引用外部函数的局部变量或包全局变量构成

闭包 = 函数 + 引用环境

```go
package main

import "fmt"

func main() {
    // 外部函数返回一个闭包函数
    greeting := getGreeting("John")
    
    // 调用闭包函数
    fmt.Println(greeting()) // 输出: Hello, John!
}

// 外部函数，接收一个名字参数，返回一个闭包函数
func getGreeting(name string) func() string {
    // 内部函数，返回一个拼接了名字的问候语字符串
    return func() string {
        return "Hello, " + name + "!"
    }
}

```

#### 闭包的作用（有点长）

闭包在编程中有几个重要的作用：

1. **保留状态：** 闭包可以捕获并保留其创建时的上下文状态。这意味着闭包函数可以访问并修改其外部函数的变量，即使外部函数已经返回，闭包仍然可以继续使用这些变量。这对于需要维护状态或记住先前状态的情况非常有用。
2. **封装数据：** 闭包允许将数据和相关操作封装在一个函数内部。通过将数据存储在闭包的上下文中，可以隐藏数据并仅通过闭包函数来访问和操作数据。这有助于实现信息隐藏和封装的概念，提高代码的可维护性和安全性。
3. **实现函数工厂：** 闭包函数可以用作函数工厂，动态创建并返回其他函数。通过为闭包提供不同的参数，可以生成具有不同行为或配置的函数。这种模式在编写可重用的代码和实现策略模式时非常有用。
4. **实现回调：** 闭包函数可以作为回调函数传递给其他函数。回调函数是在特定事件发生或特定条件满足时被调用的函数。通过将闭包作为回调函数传递，可以在回调函数中访问外部函数的变量和状态，从而实现更灵活的回调机制。

### panic和recover

简单来说，panic用来主动抛出错误，recover用来捕获panic抛出的错误

发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，逐层向上执行函数的defer语句，然后逐层打印函数调用堆栈，直到被recover捕获或执行到函数最外层后退出

```go
panic(i interface{})
recover()interface{}
```

```go
//如下场景会捕获成功
defer func(){
    println("defer inner")
    recover()
}()

func except(){
    recover()
}

func test(){
    defer except()
    panic("test")
}
```

#### panic使用场景

1.程序遇到了无法正常执行下去的错误，主动调用panic函数结束程序运行

2.在调试程序时，通过主动调用panic实现快速退出，panic打印出的堆栈能够更快地定位错误

为了保证程序的健壮性，需要主动在程序的分支流程上使用recover()拦截运行时的错误

## 类型

### 命令类型

通过标识符表示

### 未命名类型

由预声明类型、关键字和操作符组合而成。

又称为类型字面量，数组、切片、通道、指针、函数字面量、结构和接口都属于类型字面量，也都是未命名类型

```go
package main

import "fmt"

//使用type声明的是命名类型
type person struct{
    name string
    age int
}

func main(){
    //使用struct字面量声明的是未命名类型
    a := struct{
        name string
        age int
    }{"ands",18} //不建议这么用
    
    fmt.Printf("%T\n" , a) //struct {name string;age int}
    
    fmt.Printf("%v\n" , a) //{andes 18}
    
    b := Person{"Tom",21}
    fmt.Printf("%T\n" , b) //main.Person
    fmt.Printf("%v\n" ,b) //{Tom 21}
}
```

### 类型相同

两个命名类型是否相同，参考如下：

1.两个类型声明的语句完全相同

2.命名类型和未命名类型永远不相同

3.两个未命名类型相同的条件是它们的类型声明字面量结构相同，并且内部元素的类型相同

4.通过类型别名语句声明的两个类型相同

#### 类型别名

Go1.9引入了类型别名语法

```go
type T1 = T2  //T1的类型完全和T2一样
```

引入别名的原因：

1.为了解决旧包迁移兼容问题

2.Go的按包隔离机制不太精细，有时需要将大包划分为几个小包进行开发，但需要在大包里面暴露全部的类型给使用者

3.解决新旧类型迁移问题

### 类型赋值

```go
//a是类型为T1的变量，或者a本身就是一个字面常量或nil
//如果如下语句可以执行，称为类型T1可以赋值给类型T2
var b T2 = a
```

a可以赋值给变量b必须满足：

1.T1和T2类型相同

2.T1和T2具有相同的底层类型，且T1和T2里面至少有一个是未命名类型

3.T2是接口类型，T1是具体类型

4.T1和T2都是通道类型，拥有相同的元素类型，T1和T2里面至少有一个是未命名类型

5.a是nil，T2是pointer、function、slice、map、channel、interface中的一个

6.a是一个字面常量值，可以用来表示类型T的值

重要

```go
package main

import (
    "fmt"
)

type Map map[string]string

func (m Map) Print() {
    for _,key := range m {
        fmt.Println(key)
    }
}

type iMap Map

//只要底层类型是slice、map等支持range的类型字母量，新类型仍然可以使用range替代

func (m iMap) Print(){
    for _, key := range m{
        fmt.Println(key)
    }
}

type silce []int

func (s slice) Print(){
    for _, v := range s{
        fmt.Println(v)
    }
}

func main(){
    mp := make(map[string]string,10)
    mp["hi"] = "tata"
    
    //mp和ma有相同的底层类型map[string]string，且mp为未命名类型，可以赋值
    var ma Map = mp
    
    //im和ma虽有同样的底层类型map[string]string,但它们中没有一个是未命名类型，不能赋值
    var im iMap = ma //error
    
    ma.Print()
    im.Print()
    
    //Map实现了Print(),所以其可以赋值给接口类型变量
    var i interface{
        Print()
    } = ma
    
    i.Print()
    
    s1 := []int{1,2,3}
    var s2 slice
    s2 = s1
    s2.Print()
}
```



### 类型强制转换

强制类型转换的语法格式

```go
var a T = (T) (b)
```

Go是强类型语言，如果不满足自动转换的条件，则必须进行强制类型转换。

任意两个不相干的类型如果进行强制转换，则必须符合一定的规则

例如非常量类型变量x可以强制转化并传递给类型T，需满足：

1.x可以直接赋值给T类型变量

2.x的类型和T具有相同的底层类型

```go
package main

import(
    "fmt"
)

type Map map[string]string

func (m Map) Print(){
    for _, key := range m{
        fmt.Println(key)
    }
}

type iMap Map

//只要底层类型是slice、map等支持range的类型字面量，新类型仍然可以使用range迭代

func (m iMap) Print(){
    for _, key := range m{
        fmt.Println(key)
    }
}

func main(){
    mp := make(map[string]string,10)
    mp["hi"] = "tata"
    
    //mp和ma具有相同底层类型map[string]string,并且是未命名类型
    var ma Map = mp
    
    //im与ma虽然有相同的底层类型，但是二者没有一个是字面量类型，不能直接赋值，可以强制进行类型转换
    var im iMap = ma //error
    
    var im iMap = (iMap)(ma)
   
    ma.Print()
    im.Print()
}
```

3.x和T都是未命名的指针类型，并且指针指向的类型具有相同的底层类型

4.x和T都是整型，或者都是浮点型

5.x和T都是复数类型

6.x是整数型或[]byte类型的值，T是string类型

7.x是一个字符串，T是[]type或[]rune



常见字符串和切片之间的转换：

```go
s := "hello，世界"
var a []byte
a = []byte(s)

var b string
b = string(a)

var c []rune
c = []rune(s)
```

### 自定义类型

#### 用户自定义类型

语法是

```go
type newtype oldtype
```

oldtype可以是自定义类型、预声明类型、未命名类型的任意一种

newtype是新类型的标识符，与oldtype具有相同的底层类型，并且都继承了底层类型的操作集合（这里的操作不是方法，例如底层类型是map,支持range迭代访问，则新类型也可以使用range迭代访问）

newtype和oldtype是两个完全不同的类型，newtype不会继承oldtype的方法

```go
type INT int  //INT是一个使用预声明类型声明的自定义类型
type Map map[string]string //类型字面量声明的

type myMap Map //myMap是自定义类型Map声明的自定义类型
```

#### 自定义struct类型

struct类型是Go语言自定义类型的普遍形式，是Go语言类型扩展的基石，也是Go语言面向对象承载的基础

struct初始化（只写推荐写法）

```go
type Person struct{
    name string
    age int
}

//推荐初始化,以下都是
a := Person{name:"andes",age:18}

b := Person{
    name:"andes",
    age:18,
}

c:= Person{
    name : "andes",
    age : 18}
```

使用构造函数进行初始化

```go
//标准库中errors的New函数示例
//$ {GOROOT}/src/errors/errors.go
func New(text string) error {
    return &errorString{test}
}

type errorString struct{
    s string
}
```

#### 结构字段的特点

1.结构的字段可以是任意类型、基本类型、接口类型、指针类型、函数类型

2.结构字段的类型名必须唯一

3.struct字段类型可以是普通类型，也可以是指针

4.支持内嵌自身的指针

```go
//标准库container/list

type Element struct{
    //指向自身类型的指针
    next,prev *Element
    list *List
    Value interface{}
}
```

#### 匿名字段

字段只给出字段类型，没有字段名

被匿名嵌入的字段必须是命名类型或者命名类型的指针

类型字面量不能作为匿名字段使用

匿名字段的字段名默认就是类型名，如果匿名字段是指针类型，则默认的字段名则是指针指向的类型名

```go
//标准库${GOROOT}/src/os/type.go
type File struct{
    *file //os specific
}
```

### 方法

为命名类型定义方法的语法格式如下：

```go
//类型方法的接收者是值类型
func (t TypeName)MethodName(ParamList)(Returnlist){
    //method body
}
//类型方法的接收者是指针
func (t *TypeName)MethodName(ParamList)(Returnlist){
    //method body
}
```

Go语言的类型方法本质上就是一个函数，没有使用隐式的指针，简单明了。

将类型方法改写成常规函数：

```go
//类型方法接收者是值类型
func TypeName_MethodName(t TypeName,otherParamList)(Returnlist){
    //method body
}
//类型方法接收者是指针类型
func TypeName_MethodName(t *TypeName,otherParamList)(Returnlist){
    //method body
}
```

```go
//示例
type SliceInt []int
func (s SliceInt) Sum() int{
    sun := 0
    for _ , i := range s{
        sum += i
    }
    return sum
}
//与上面的方法等价
func SliceInt_Sum(s SliceInt) int{
    sum := 0
    for _ , i := range s{
        sum += i
    }
    return sum
}

var s SliceInt = []int{1,2,3,4}
s.Sum()
Slice_Sum(s)
```

#### 方法调用

一般调用方式

```go
TypeInstanceName.MethodName(ParamList)
```

TypeInstanceName:类型实例名或者指向实例的指针变量名

MethodName:类型方法名

ParamList:方法实参

```go
type T struct{
    a int
}

func (t T) Get() int{
    return t.a
}

func (t *T) Set(i int){
    t.a = i
}

var t = &T{}

t.Set(2)

t.Get()
```

#### 方法值

变量x的静态类型是T，M是类型T的一个方法，x.T被称为方法值

方法值是一个函数类型变量，可以赋值给其他变量，并可以像普通的函数名一样使用

```go
f := x.M
f(args...)

//等价于
x.M(args...)
```

示例：

```go
type T struct{
    a int
}

func (t T) Get() int{
    return t.a
}

func (t *T) Set(i int){
    t.a = i
}

func (t *T) Print(){
    fmt.Printf("%p,%v,%d \n",t,t,t.a)
}

var t = &T{}

f := t.Set

f(2)
t.Print()

f(3)
t.Print()
```

#### 方法表达式

方法表达式相当于提供一种语法将类型方法调用显式地转换为函数调用，接收者必须显式地传递出去。

拿这个例子做解释

```go
type T struct{
    a int
}

func (t T) Get() int{
    return t.a
}

func (t *T) Set(i int){
    t.a = i
}

func (t *T) Print(){
    fmt.Printf("%p,%v,%d \n",t,t,t.a)
}

//以下方法表达式调用都是等价的
t := T{
    a : 1,
}

//普通方法调用
t.Get(t)

//方法表达式调用
(T).Get(t)

//方法表达式调用
f1 := T.Get; f1(t)

//方法表达式调用
f2 := (T).Get; f2(t)


(*T).Set(&t,1)
f3 := (*T).Set(); f3(&t,1)
```

表达式T.Get()和(*T).Set被称为方法表达式

方法表达式可以看作函数名，只不过函数的首个参数需要是接收者的实例或者指针

T.Get的函数签名是func(t T) int

(*T).Set的函数签名是func(t *T, i int)

如果写反了在方法表达式中编译器不会自动转换

#### 方法集

命名类型方法接收者有两种类型，一种是值类型，另一种是指针类型

无论接收者是什么类型，方法和函数的实参传递都是值拷贝，传的是副本

```go
package main

import "fmt"

type Int int

func (a Int) Max(b Int) Int{
    if a >= b{
        return a
    }else{
        return b
    }
}

func (i *Int) Set(a Int){
    *i = a
}

func (i Int) Print(){
    fmt.Printf("value=%d\n",i)
}

func main(){
    var a Int = 10
    var b Int = 20
    
    c := a.Max(b)
    c.Print()
    (&c).Print()
    
    a.Set(20)
    a.Print()
    
    (&a).Set(30)
    a.Print()
}
```

定义了新类型Int,其底层类型是int

Int虽然不能继承int的方法，但底层类型支持的操作（算术运算和赋值运算）可以被上层类型继承，这是Go的一大特点

上述例子：

接收者是Int类型的方法集合:

```go
func (i Int) Print()
func (a Int) Max(b Int) Int
```

接收者是*Int类型的方法集合：

```go
func (i *Int) Set(a Int)
```

将接收者的值类型T的方法的集合记录为S，将接收者为指针类型**T*的方法的集合统称为*S：

1.T类型的方法集是S

2.**T*类型的方法集是S和*S

注意：示例中，无论值类型变量还是指针类型变量，都可以调用类型的所有方法，那是因为编译器在编译期间能够识别出这种调用关系，做了自动的转换

### 组合 Go的“继承”

#### 组合

命名结构类型可以嵌套其他的命名类型的字段，外层的结构类型是可以调用嵌入字段类型的方法，这种调用既可以是显式的调用，也可以是隐式的调用。

Go语言没有继承的语义，所以我在继承上打了双引号

结构和字段之间是"has a"的关系，而不是"is a"的关系

没有父子的概念，仅仅是整体和局部的概念

称这种嵌套的结构和字段的关系为**组合**

#### 内嵌字段

由于struct可以嵌套其他struct字段，所以组合也可以分层次扩展

struct类型中的字段称为“内嵌字段”

##### 内嵌字段的初始化和访问

struct的字段访问使用点操作符"."，struct的字段可以嵌套很多层，只要内嵌的字段是唯一的即可

```go
package main

type X struct{
    a int
}

type Y struct{
    X
    b int
}

type Z struct{
    Y
    c int
}

func main(){
    x := X{
        a : 1,
    }
    
    y := Y{
        X : x,
        b : 2,
    }
    
    z := Z{
        Y : y,
        c : 3,
    }
    
    //z.a z.Y.a z.Y.X.a 三者等价  z.a z.Y.a是z.Y.X.a的简写
    println(z.a, z.Y.a, z.Y.X.a)  //1 1 1
    
    z = Z{}
    z.a = 2
    println(z.a, z.Y.a, z.Y.X.z)  //2 2 2
}
```

##### 内嵌字段的方法调用

也使用点操作符

不同嵌套层次的字段可以有相同的方法

外层变量调用内嵌字段方法时也可以像嵌套字段访问一样使用简化模式

如果外层字段和内层字段有相同方法，则使用简化模式访问外层的方法会覆盖内层的方法（Go编译器优先从外向内逐层查找方法，同名方法中外层的方法能够覆盖内层的方法

```go
package main

import "fmt"

type X struct{
    a int
}

type Y struct{
    X
    b int
}

type Z struct{
    Y
    c int
}

func (x X) Print(){
    fmt.Printf("In X, a=%d\n",x.a)
}

func (x X) XPrint(){
    fmt.Printf("In X, a=%d\n",x.a)
}

func (y Y) Print(){
    fmt.Printf("In Y, b=%d\n",y.b)
}

func (z Z) Print(){
    fmt.Printf("In Z, c=%d\n",z.c)
    
    //显式的完全路径调用内嵌字段的方法
    z.Y.Print()
    z.Y.X.Print()
}

func main(){
    x := X{a : 1}
    
    y := Y{
        X : x,
        b : 2,
    }
    
    z := Z{
        Y : y,
        c : 3,
    }
    
    //从外向内查找，首先查找的是Z的Print()方法
    z.Print()
    
    //最后找到的是X的XPrint()方法
    z.XPrint()
    z.Y.XPrint()
}
```

不推荐内嵌多个同名的字段

但是不反对struct定义和内嵌字段同名方法的用法，因为这提供了一种编程技术，使得struct能够重写内嵌字段的方法，提供面向对象编程中子类覆盖父类同名方法的功能

#### 组合的方法集

与前文所说的方法集道理类似

```go
package main

type X struct{
    a int
}

type Y struct{
    X
}

type Z struct{
    *X
}

func (x X) Get() int {
    return x.a
}

func (x *X) Set(i int){
    x.a = i
}

func main(){
    x := X{a : 1}
    
    y := Y{
        X : x,
    }
    
    Println(y.Get())  //1
    
    //此处编译器做了自动转换
    y.Set(2)
    Println(y.Get()) //2
    
    //为了不让编译器做自动转换，使用方法表达式调用方式
    //Y内嵌字段X,所以type Y的方法集是Get,type *Y的方法集是Set和Get 
    (*Y).Set(&y,3)
    
    //type Y的方法集合并没有Set方法
    //Y.Set(y,3)
    
    Println(y.Get())
    
    z := Z{
        X : &x,
    }
    
    //按照嵌套字段的方法集规则
    //Z 内嵌字段*X,所以type Z和type *Z方法集都包含类型X定义的方法Get和Set
    
    //为了不让编译器做自动转换，仍然使用方法表达式调用方式
    Z.Set(z, 4)
    Println(z.Get()) //4
    
    (*Z).Set(&z,5)
    Println(z.Get())  //5
}
```

值得注意的是，编译器的自动转换仅适用于直接通过类型实例调用方法时才有效，类型实例传递给接口时，编译器不会进行自动转换，而是会进行严格的方法集校验

## 接口

接口是一个编程规约，也是一组方法签名的集合

Go的接口是非侵入式的设计，也就是说，一个具体类型实现接口不需要在语法上显式地声明，只要具体类型的方法集是接口方法的超集，就代表实现了接口，编译器在编译时会进行方法集的校验

接口是没有具体实现逻辑的，也不能定义字段



接口变量只有值和实例的概念，所以接口类型变量仍然称为接口变量，接口内部存放的具体类型变量被称为接口指向的“实例”



接口只有声明没有实现

引用类型

### 空接口

空接口：

```go
interface{}
```

由于空接口的方法集为空，所以任意类型都被认为实现了空接口，任意类型的实例都可以赋值或传递给空接口，包括非命名类型的实例

空接口是反射实现的基础，反射库就是将相关具体类型转换并赋值给空接口后才去处理

### 接口声明

常用使用接口命名类型type关键字声明

```go
type InterfaceName interface{
    MethodSignature1
    MethodSignature2
}
```

使用接口字面量类型的声明很少

```go
interface{
   MethodSignature1
   MethodSignature2
}
```

接口支持嵌入匿名接口字段，即一个接口定义里面可以包括其他接口，编译器会自动进行展开处理

```go
type Reader interface{
    Read(p []byte) (n int, err error)
}

type Writer interface{
    Write(p []byte) (n int,err error)
}

//以下三种声明均等价，最终展开模式都是第三种格式
type ReadWriter interface{
    Reader
    Writer
}

type ReadWriter interface{
    Reader
    Writer(p []byte) (n int,err error)
}

type ReadWriter interface{
    Reader(p []byte) (n int, err error)
    Writer(p []byte) (n int,err error)
}
```

#### 方法声明

```go
//方法声明 = 方法名 + 方法签名

MethodName (InputTypeList)OutputTypeList
```

声明新接口类型的特点

1.接口命名一般以"er"结尾

2.接口定义的内部方法声明不需要func引导

3.在接口定义中，只有方法声明没有方法实现

### 接口方法调用

直接调用未初始化的接口变量方法会产生panic

```go
package main

type Printer interface{
    Print()
}

type S struct{}

func (s S) Print(){
    println("print")
}

func main(){
    var i Printer
    
    //没有初始化的接口调用其方法会产生panic
    // i.Print()
    
    //需要初始化
    i = S{}
    i.Print()
}
```

### 接口的动态类型和静态类型

动态类型：接口绑定的具体实例的类型

静态类型：接口被定义时，其类型就是静态类型

接口的动态类型随绑定的不同类型实例而发生变化

静态类型的本质特征就是接口的方法签名集合

### 类型断言

语法形式如下

```go
i.(TypeName)  // i必须是接口变量，TypeName可以是接口类型名，也可以是具体类型名
```

1.如果TypeName是一个具体类型名，则判断i绑定的实例类型是否就是具体类型TypeName

2.如果TypeName是一个接口类型名，则判断i绑定的实例类型是否同时实现了TypeName接口

接口断言还有直接赋值模式，如下：

```go
o := i.(TypeName)
```

一个例子：

```go
package main

import "fmt"

type Inter interface{
    Ping()
    Pong()
}

type Anter interface{
    Inter
    String()
}

type St struct{
    Name string
}

func (St) Ping(){
    println("ping")
}

func (*St) Pang(){
    println("pang")
}

func main(){
    st := &St{"andes"}
    var i interface{} = st
    
    //判断i绑定的实例是否实现了接口类型Inter
    o := i.(Inter)
    o.Ping()
    o.Pang()
    
    //i没有实现接口Anter
    //p := i.(Anter)
    //p.String()
    
    //判断i绑定的实例是否就是具体类型St
    s := i.(*St)
    fmt.Printf("%s",s.Name)
    
    if o,of := i.(TypeName) ; ok{
        
    }
}
```

### 类型查询

接口类型查询语法格式如下：

```go
switch v := i.(type){ 
    case type1:
    xxxx
    case type2:
    xxxx
    default:
    xxxx
}
```

### 接口的优点

1.解耦：复杂系统进行垂直和水平的分割是常用的设计手段，层与层之间使用接口进行抽象和解耦是一种好的编程策略

2.实现泛型：使用空接口作为函数或方法参数能够使用在需要泛型的场景中

### 接口使用场景

主要使用在：

1.作为结构内嵌字段

2.作为函数或方法的形参

3.作为函数或方法的返回值

4.作为其他接口定义的嵌入字段

### 接口的内部实现

非空接口的数据结构是iface,代码位于src/runtime/runtime2.go

```go
type iface struct{
    tab *itab  //itab存放类型及方法指针信息
    data unsafe.Pointer  //数据信息
}
```

```go
type itab struct{
    inter *interfacetype //接口自身的静态类型
    _type *_type //_type就是接口存放的具体实例的类型（动态类型）
    //hash存放具体类型的Hash值
    hash uint32
    _ [4]byte
    fun [1]uintptr
}
```

空接口的数据结构是eface

```go
type eface struct{
    _type *_type
    data unsafe.Pointer
}
```

## 并发

现有的软件对并发支持不是很好，Go语言就是在这个背景下诞生的

### 并发和并行

并行：程序在任意时刻都是同时运行的，是在任一粒度的时间内具备同时执行的能力，最简单的并行就是多机，但由于是共享内存，以及线程间的同步，不可能完全做到并行

并发：程序在单位时间内是同时运行的，在规定的时间内多个请求都得到执行和处理，强调的是给外界的感觉，实际上内部可能还是分时操作的

并行是硬件和操作系统开发者重点考虑的问题

在当前的计算机体系下：并行具有瞬时性，并发具有过程性；并发在于结构，并行在于执行

一个应用程序具备好的并发结构，操作系统才能更好地利用硬件并行执行，同时避免阻塞等待，合理地进行调度，提升CPU利用率

### goroutine

Go语言的并发执行体称为goroutine,英文翻译是例程

通过go+匿名函数启动gorouinte

```go
package main

import(
    "runtime"
    "time"
)

func main(){
    go func(){
        sum := 0
        for i :=0;i < 1000; i++{
            sum += i
        }
        println(sum)
        time.Sleep(1 * time.Second)
    }()
    
    //NumGoroutine可以返回当前程序的goroutine数目
    println("NumGoroutine=", runtime.NumGoroutine())
    
    //main goroutine故意"sleep"5秒，防止提前退出
    time.Sleep(5 * time.Second)
}

//NumGoroutine = 2
```

通过go + 有名函数启动goroutine

```go
package main

import(
    "runtime"
    "time"
)

func sum(){
      sum := 0
      for i :=0;i < 1000; i++{
          sum += i
      }
      println(sum)
      time.Sleep(1 * time.Second)
}
func main(){
    go sum()
    //NumGoroutine可以返回当前程序的goroutine数目
    println("NumGoroutine=", runtime.NumGoroutine())
    
    //main goroutine故意"sleep"5秒，防止提前退出
    time.Sleep(5 * time.Second)
}
```

### goroutine特性

go的执行是非阻塞的，不会等待

go后面的函数的返回值会被忽略

调度器不能保证多个goroutine的执行次序

没有父子goroutine的概念，所有的goroutine是平等地被调度和执行的

Go程序在执行时会单独为main函数创建一个goroutine，遇到其他go关键字时再去创建其他的goroutine

Go没有暴露goroutine id给用户，所以不能在一个goroutine里面显式地操作另一个goroutine，不过runtime包提供了一些函数访问和设置goroutine相关信息

#### 一些关于goroutine的API

##### func GOMAXPROCS(n int) int

用来设置或查询可以并发执行的goroutine数目，当n大于1表示设置GOMAXPROCS值，否则表示查询当前GOMAXPROCS值

##### func Goexit()

结束当前goroutine的运行，Goexit在结束当前goroutine运行之前会调用当前goroutine已经注册的defer。

Goexit并不会产生panic，所以recover返回都为nil

##### func Gosched()

放弃当前调度执行机会，将当前goroutine放到队列中等待下次被调度

### Chan通道

通道

引用类型

goroutine之间通信和同步的重要组件

“不要通过共享内存来通信，要通过通信来共享内存

Go语言提供一个内置函数make来创建通道

```go
//创建一个无缓冲的通道，通道存放元素类型为datatype
make(chan datatype)

//创建一个有10个缓冲的通道，通道存放元素的类型为datatype
make(chan datatype,10)
```

无缓冲通道：len和cap都是0，可以用于通信，也可以用于两个goroutine的同步

有缓冲通道：len代表没有被读取的元素数，cap代表整个通道的容量

有了通道后，可以使用无缓冲的通道来实现goroutines之间的同步等待：

```go
package main

import(
    "runtime"
)

func main(){
    c := make(chan struct{})
    go func(i chan struct{}){
        sum := 0
        for i := 0; i < 10000; i++{
            sum += i
        }
        println(sum)
        //写通道
        c <- struct{}{}
    }(c)
    
    println("NumGoroutine=",runtime.NumGoroutine())
    //读通道，通过通道进行同步等待
    <-c
}
```

goroutine运行结束后退出，写到缓冲通道中的数据不会消失，它可以缓冲和适配两个goroutine处理速率不一致的情况，缓冲通道和消息队列类似，有削峰和增大吞吐量的功能

```go
package main

import(
    "runtime"
)

func main(){
    c := make(chan struct{})
    ci := make(chan int,100)
    go func(i chan struct{},j chan int){
        for i := 0; i < 10; i++{
            ci <- i
        }
        close(ci)
        //写通道
        c <- struct{}{}
    }(c,ci)
    
    println("NumGoroutine=",runtime.NumGoroutine())
    //读通道c，通过通道进行同步等待
    <-c
    
    //此时ci通道已经关闭，匿名函数启动的goroutine已经退出
    println("NumGoroutine=",runtime.NumGoroutine())
    
    //但通道ci仍可以继续读取
    for v := range ci{
        println(v)
    }
}
```

操作不同状态的chan会引发三种行为

**panic**

1.向已经关闭的通道写数据会panic（最好就是由写入者去关闭通道）

2.重复关闭的通道会panic

**阻塞**

1.向未初始化的通道写数据或读数据都会导致当前goroutine永久阻塞

2.向缓冲区已满的通道写入数据会导致goroutine阻塞

3.通道中没有数据，读取该通道会导致goroutine阻塞

**非阻塞**

1.读取已经关闭的通道不会引发阻塞，而是立即返回通道元素类型的零值，可以使用comma，ok语法判断通道是否关闭

2.向有缓冲且没有满的通道读/写不会引起阻塞

#### Chan的底层结构

```go
type hchan struct {
    qcount   uint           // 当前通道中的元素数量
    dataqsiz uint           // 缓冲区大小（非缓冲通道为0）
    buf      unsafe.Pointer // 指向元素数据的指针（循环队列）
    elemsize uint16         // 单个元素的大小
    closed   uint32         // 是否关闭的标志
    elemtype *_type         // 元素的类型
    sendx    uint           // 发送索引
    recvx    uint           // 接收索引
    recvq    waitq          // 接收等待队列
    sendq    waitq          // 发送等待队列
    lock     mutex
}
```



### WaitGroup

sync包提供多个goroutine同步的机制，主要通过WaitGroup实现的

```go
type WaitGroup struct{
    //contains filtered or unexported fields
}

//添加等待信号
func (wg *WaitGroup) Add(delta int)

//释放等待信号
func (wg *WaitGroup) Done()

//等待
func (wg *WaitGroup) Wait()
```

WaitGroup用来等待多个goroutine完成，main goroutine调用Add设置需要等待goroutine的数目，每一个goroutine结束时调用Done()，Wait()被main用来等待所有goroutine完成

看个例子如何用sync.WaitGroup完成多个goroutine之间的协同工作

```go
package main

import(
    "net/http"
    "sync"
)

var wg sync.WaitGroup
var urls = []string{
    "http://www.golang.org/"
    "http://www.google.com/"
    "http://www.qq.com"
}

func main(){
    for _, url := range urls{
        //每一个URL启动一个goroutine,同时给wg加1
        wg.Add(1)
        
        go func(url string){
            //当前goroutine结束后给wg计数减一，wg.Done() = wg.Add(-1)
            defer wg.Done()
            
            //发送HTTP get请求并打印HTTP返回码
            resp, err := http.Get(url)
            if err == nil{
                println(resp.Status)
            }
        }(url)
    }
    //等待所有请求结束
    wg.Wait()
}
```

### Select

selct是类UNIX系统提供的一个多路复用系统API，select关键字用于多路监听多个通道

当监听的通道没有状态是可读或可写的，select为阻塞

只要监听的通道中有一个状态是可读或可写的，则select就不会阻塞，而是进入处理就绪通道的分支流程

如果监听的通道有多个可读或可写的状态，则select随机选取一个处理

```go
package main

func main(){
    ch := make(chan int ,1)
    go func(chan int){
        for{
            select {
                //0or1写入随机
            case ch <- 0:
            case ch <- 1:
            }
        }
    }(ch)
    for i := 0;i < 10; i++{
        println(<-ch)
    }
}
```

### 扇入和扇出

扇入：多路通道聚合到一条通道中处理，Go最简单的扇入就是使用select聚合多条通道服务

扇出：一条通道发散到多条通道中处理

### 通知退出机制

读取已经关闭的通道不会引起阻塞，也不会导致panic，而是立即返回该通道存储类型的零值，关闭select监听的某个通道能使select立即感知这种通知，然后进行相应的处理，这就是所谓的退出通知机制

随机数生成器演示退出通知机制

```go
package main

import (
    "fmt"
    "math/rand"
    "runtime"
)

func GenerateIntA(done chan struct()) chan int{
    ch := make(chan int)
    go func{
        Lable:
        for{
            select {
                case ch <- rand.Int():
                //增加一路监听，对退出通知信号done的监听
                case <- done:
                break Lable
            }
        }
        //收到通知后关闭通道ch
        close(ch)
    }()
    return ch
}

func main(){
    done := make(chan struct{})
    ch := GenerateIntA(done)
    
    fmt.Println(<-ch)
    fmt.Println(<-ch)
    
    //发送通知，告诉生产者停止生产
    close(done)
    
    fmt.Println(<-ch)
    fmt.Println(<-ch)
    
    //此时生产者已经退出
    Println("NumGoroutine=", runtime.NumGoroutine())
}
```

### Goroutine调度模型

**G(Goroutine)**

G是Go运行时对goroutine的抽象描述，G中存放并发执行的代码入口地址、上下文、运行环境（关联的P和M）、运行栈等执行相关的元信息

G的新建、休眠、恢复、停止都受到go运行时的管理

**M(Machine)**

M代表OS内核线程，是操作系统层面调度和执行的实体。

M仅负责执行，M不停地被唤醒和创建，然后执行

**P(Processor)**

P代表M运行G所需要的资源，是对资源的一种抽象和管理，P不是一段代码实体，而是一个管理的数据结构

P主要是降低M管理调度G的复杂性，增加一个间接的控制层数据结构

#### GMP调度过程（简）

当一个新的Goroutine被创建时，它被放入全局队列中。 空闲的M从全局队列中获取一个Goroutine，并开始执行它。 如果Goroutine在执行过程中发生了系统调用或阻塞，关联的M会被释放出来，让出处理器。 空闲的M会在本地队列中寻找其他等待执行的Goroutines，以保持快速响应。 如果本地队列为空，M会重新加入全局队列，等待调度器将新的Goroutine分配给它。

#### GMP的数量问题

M的数量：

M（操作系统线程）的数量由Go运行时系统自动管理。它们负责执行Goroutine，并在Goroutine阻塞等待时处理系统调用等操作。

Go运行时系统会根据需要自动创建和销毁M，以适应系统负载。这意味着在不同的时间点，系统中可能有多个M在运行。

P的数量：

P（处理器）是一种逻辑实体，负责管理和调度Goroutine的执行。

P的数量由`GOMAXPROCS`环境变量或`runtime.GOMAXPROCS`函数来设置。它决定了同时执行的Goroutine的数量。在单核处理器上，可以将P的数量设置为1，以便Goroutine交替执行。

P的数量通常与可用的CPU核心数量相对应，这允许Go程序在多核系统上充分利用并行性。

## 反射

本章不会详细说明反射（以后再更。。）

反射就是程序能够在运行时动态地查看自己的状态，并且允许修改自身的行为

Go语言反射的基础是接口和类型系统，是编译器和运行时把类型信息以合适的数据结构保存在可执行程序中

### 反射API

#### 从实例到Value

```go
func ValueOf(i interface{}) Value
```

#### 从实例到Type

```go
func TypeOf(i interface{}) Type
```

#### 从Type到Value

```go
func New(typ Type) Value
```

```go
func Zero(typ Type) Value
```

如果知道类型值的底层存放地址

```go
func NewAt(typ Type, p unsafe.Pointer) Value
```

#### 从Value到Type

```go
func (v Value) Type() Type
```

#### 从Value到实例

```go
func (v Value) interface() (i interface{})
```

#### 从Value的指针到值

```go
func (v Value) Elem() Value
```

```go
//不会引起panic
func Indirect(v Value) Value
```

#### Type指针和值的相互转换

1.指针类型Type到值类型Type

```go
t.Elem() Type
```

2.值类型Type到指针类型Type

```go
func PtrTo(t Type) Type
```

#### Value值的可修改性

涉及以下两种方法

```go
//通过CanSet判断能否修改
func (v Value) CanSet() bool
```

```go
//通过Set进行修改
func (v Value) Set(x Value)
```

### 反射三定律

1.反射可以从接口值得到反射对象

2.反射可以从反射对象获得接口值

3.若要修改一个反射对象，则其值必须可以修改



## 情景题

### 当系统出现卡顿，应该怎么排查？

1. **观察系统指标**：首先查看系统的CPU、内存和磁盘使用情况，以确定性能问题。
2. **检查日志**：分析系统和应用程序的日志文件，寻找错误信息和警告。
3. **性能分析**：使用性能工具，如`top`，检查哪些进程占用资源。
4. **数据库查询**：检查数据库慢查询日志，优化查询语句和索引。
5. **网络请求**：确认网络请求是否引起卡顿。
6. **内存和锁**：查找内存泄漏和锁问题，这可能导致系统卡顿。
7. **硬件和版本控制**：检查硬件状态和代码变更。
8. **监控工具**：使用监控工具来实时跟踪系统性能
